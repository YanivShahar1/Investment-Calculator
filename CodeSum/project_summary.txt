

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\app.py ---

from flask import Flask, render_template, request, jsonify
import logging
from services import cache, fetch_stock_data_batch, generate_data_points, VisualizationService, get_inflation_data
import hashlib
import json
from config import get_config
import pandas as pd
import os

def create_app(config_name=None):
    app = Flask(__name__)
    
    config = get_config(config_name)
    app.config.from_object(config)
     # Set up the correct data directory path
    app.config['DATA_DIR'] = os.path.join(app.root_path, 'services', 'data')

    # Set up logging
    logging.basicConfig(
        level=app.config['LOG_LEVEL'],
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)

    cache.init_app(app)

    def cache_key():
        """Generate a cache key based on the request data."""
        data = request.get_json()
        data['stocks'] = sorted(data['stocks'])
        return hashlib.md5(json.dumps(data, sort_keys=True).encode()).hexdigest()

    @app.route('/')
    def index():
        return render_template('index.html')

    @app.route('/calculate', methods=['POST'])
    @cache.cached(timeout=300, key_prefix=cache_key)

    
    def calculate():
        try:
            data = request.json
            logger.info(f"Received calculation request: {data}")

            # Validate input data
            try:
                initial_investment = float(data['initialInvestment'])
                start_year = int(data['startYear'])
                end_year = int(data['endYear'])
                stock_symbols = data['stocks']
                addition_amount = float(data['additionAmount'])
                addition_frequency = data['additionFrequency']
                adjust_for_inflation = data['adjustForInflation']
            except (KeyError, ValueError) as e:
                logger.error(f"Invalid input parameters: {str(e)}")
                return jsonify({
                    'error': 'Invalid input parameters',
                    'details': str(e)
                }), 400

            # Validate date range
            if end_year <= start_year:
                return jsonify({
                    'error': 'Invalid date range',
                    'details': 'End year must be greater than start year'
                }), 400

            try:
                # Fetch stock data with error handling
                logger.info(f"want to fetch stock data for symbols: {stock_symbols}")
                stocks, invalid_symbols, data_issues = fetch_stock_data_batch(stock_symbols, start_year, end_year)
                logger.info(f"Fetched {len(stocks)} valid stocks out of {len(stock_symbols)} requested")

                if invalid_symbols:
                    logger.warning(f"Invalid symbols found: {invalid_symbols}")

                if not stocks:
                    return jsonify({
                        'error': f'No valid stock data for stocks {stock_symbols}',
                        'details': {
                            'invalidSymbols': invalid_symbols,
                            'message': f"No valid data found for any symbols. Please check: {', '.join(invalid_symbols)}"
                        }
                    }), 400

                # # Validate data range for each stock
                # data_issues = {}
                # for symbol, data in stocks.items():
                #     if data.empty:
                #         data_issues[symbol] = "No data available"
                #         continue

                #     first_date = data.index[0]
                #     last_date = data.index[-1]
                    
                #     if first_date.year > start_year:
                #         data_issues[symbol] = f"Data only available from {first_date.year}"
                #     elif last_date.year < end_year - 1:
                #         data_issues[symbol] = f"Data only available until {last_date.year}"

                #     logger.info(f"data for symbol {symbol}: {data}")

                # Prepare response with warnings if needed
                response_data = {}
                if invalid_symbols or len(data_issues) > 0:
                    logger.info(f"invalid or (len = {len(data_issues)}) invalid :  {invalid_symbols}")
                    response_data['warnings'] = {
                        'invalidSymbols': invalid_symbols,
                        'dataIssues': data_issues,
                        'message': "Some stocks had issues with data availability"
                    }

                # Generate data points
                logger.info('Generating data points...')
                try:
                    results = generate_data_points(
                        initial_investment, 
                        start_year, 
                        end_year, 
                        stocks,
                        addition_amount, 
                        addition_frequency, 
                        adjust_for_inflation
                    )
                except Exception as e:
                    logger.error(f"Error generating data points: {str(e)}")
                    return jsonify({
                        'error': 'Calculation error',
                        'details': str(e)
                    }), 400

                # Generate visualization
                try:
                    vis_service = VisualizationService()
                    graph_json = vis_service.generate_graph(results)
                except Exception as e:
                    logger.error(f"Error generating visualization: {str(e)}")
                    return jsonify({
                        'error': 'Visualization error',
                        'details': str(e)
                    }), 400

                # Add results to response
                response_data.update({
                    'data': results,
                    'graph': graph_json
                })

                logger.info("Calculation completed successfully")
                return jsonify(response_data)

            except Exception as e:
                logger.error(f"Error processing stock data: {str(e)}")
                return jsonify({
                    'error': 'Data processing error',
                    'details': str(e)
                }), 400

        except Exception as e:
            logger.exception(f"Unexpected error in calculate route: {str(e)}")
            return jsonify({
                'error': 'Server error',
                'details': 'An unexpected error occurred'
            }), 500


    @app.route('/api/inflation')
    def get_inflation():
        """Get inflation data endpoint"""
        try:
            data = get_inflation_data()
            if data is None:
                return jsonify({
                    'error': 'Failed to load inflation data',
                    'details': 'Data file not found or invalid'
                }), 500
            return jsonify(data)
        except Exception as e:
            logger.error(f"Error fetching inflation data: {str(e)}")
            return jsonify({
                'error': 'Failed to fetch inflation data',
                'details': str(e)
            }), 500

    from services.stock_list_service import get_stock_list, search_stocks



    @app.route('/api/stocks')
    def get_stocks():
        """Get list of available stocks"""
        try:
            return jsonify(get_stock_list())
        except Exception as e:
            logger.error(f"Error fetching stock list: {str(e)}")
            return jsonify({
                'error': 'Failed to fetch stock list',
                'details': str(e)
            }), 500

    @app.route('/api/stocks/search')
    def search():
        """Search stocks by query"""
        try:
            query = request.args.get('q', '')
            if not query:
                return jsonify([])
            results = search_stocks(query)
            return jsonify(results)
        except Exception as e:
            logger.error(f"Error searching stocks: {str(e)}")
            return jsonify({
                'error': 'Search failed',
                'details': str(e)
            }), 500

    @app.errorhandler(404)
    def not_found_error(error):
        return jsonify({
            'error': 'Not found',
            'details': 'The requested resource was not found'
        }), 404

    @app.errorhandler(500)
    def internal_error(error):
        logger.exception("An internal error occurred")
        return jsonify({
            'error': 'Internal server error',
            'details': 'An unexpected error occurred'
        }), 500

    return app

if __name__ == '__main__':
    app = create_app('development')
    app.run(debug=app.config['DEBUG'])

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\config.py ---

import os
from datetime import timedelta

class Config:
    # Use environment variables for sensitive data
    SECRET_KEY = os.environ.get('SECRET_KEY') or None
    if not SECRET_KEY:
        raise ValueError("No SECRET_KEY set in environment variables")
    
    # Flask-Caching settings
    CACHE_TYPE = os.environ.get('CACHE_TYPE', 'simple')
    
    # Debug mode
    DEBUG = False
    
    # Logging
    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')
    
    # CORS settings
    CORS_ORIGINS = ['http://localhost:5000', 'http://127.0.0.1:5000']

    CELERY_BROKER_URL = 'redis://localhost:6379/1'
    CELERY_RESULT_BACKEND = 'redis://localhost:6379/2'
    CACHE_REDIS_URL = 'redis://localhost:6379/0'

class DevelopmentConfig(Config):
    DEBUG = True
    LOG_LEVEL = 'DEBUG'
    CACHE_TYPE = 'simple'

class ProductionConfig(Config):
    DEBUG = False
    CACHE_TYPE = 'redis'
    LOG_LEVEL = 'INFO'
    
    # Production security settings
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    PERMANENT_SESSION_LIFETIME = timedelta(days=7)

config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}

def get_config(config_name=None):
    if config_name is None:
        config_name = os.environ.get('FLASK_CONFIG', 'default')
    return config.get(config_name, config['default'])

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\README.md ---

# Investment Comparison Calculator Documentation

## Overview

The Investment Comparison Calculator is a web application that allows users to compare the growth of investments across multiple stocks over a specified time period. It fetches real historical stock data and visualizes the growth of an initial investment amount for each selected stock.

## Technologies Used

1. **Flask**: A lightweight WSGI web application framework in Python. It's used to create the web server and handle HTTP requests.

2. **Plotly**: A graphing library for making interactive, publication-quality graphs. It's used to create the investment growth chart.

3. **yfinance**: A Python library that allows for easy downloading of financial data from Yahoo Finance. It's used to fetch historical stock data.

4. **HTML/JavaScript**: Used for creating the user interface and handling client-side interactions.

5. **Tailwind CSS**: A utility-first CSS framework used for styling the web interface.

## Application Structure

- `app.py`: The main Flask application file containing server-side logic.
- `templates/index.html`: The HTML template for the web interface.
- `requirements.txt`: Lists the Python packages required to run the application.

## How It Works

1. **User Input**: Users enter an initial investment amount, start year, end year, and one or more stock symbols.

2. **Data Fetching**: When the user clicks "Calculate", the application sends a request to the server with the input data.

3. **Server-side Processing**:
   - The server uses `yfinance` to fetch historical stock data for each entered symbol.
   - It calculates the growth of the initial investment for each stock over the specified time period.

4. **Data Visualization**: The server generates a Plotly graph showing the investment growth for each stock.

5. **Result Display**: The graph is sent back to the client and displayed in the browser.

## Key Functions

- `fetch_stock_data(symbol, start_year, end_year)`: Fetches historical stock data using yfinance.
- `generate_data_points(initial, start_year, end_year, stocks)`: Calculates investment growth for each stock over time.
- `calculate()`: Main function that handles the calculation request and returns the graph data.

## How to Use

1. Enter the initial investment amount in dollars.
2. Specify the start year and end year for the comparison.
3. Enter one or more stock symbols (e.g., AAPL for Apple, GOOGL for Google).
4. Click "Add Stock" to add fields for more stock symbols if needed.
5. Click "Calculate" to generate the comparison graph.
6. The resulting graph shows the growth of the initial investment for each stock over time.

## Error Handling

- The application includes error handling for invalid inputs and issues with data fetching.
- Users are alerted if there's an error in fetching data for a particular stock.

## Limitations

- The accuracy of the calculation depends on the availability and accuracy of data from Yahoo Finance.
- The application does not account for dividends or stock splits.
- It assumes a buy-and-hold strategy and does not consider periodic investments or rebalancing.

## Future Enhancements

Potential improvements for the application include:
- Adding support for different currencies
- Incorporating dividend reinvestment in calculations
- Allowing for periodic investments rather than just an initial lump sum
- Adding more detailed financial metrics and analysis

## Conclusion

The Investment Comparison Calculator provides a user-friendly way to visualize and compare the historical performance of different stocks. It's a valuable tool for basic investment research and education, helping users understand how different stocks have performed over time.

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\__init__.py ---

"""
Investment Calculator Package

A web application for comparing investment growth across multiple stocks over time.
Provides tools for calculating and visualizing investment returns with features like:
- Multiple stock comparison
- Periodic investment additions
- Inflation adjustment
- Interactive visualizations
"""

from services.calculation_service import CalculationService
from services.stock_service import fetch_stock_data, fetch_stock_data_batch, fetch_inflation_data
from services.data_service import generate_data_points
from services.cache_service import cache

__version__ = '1.0.0'
__author__ = 'Your Name'
__email__ = 'your.email@example.com'

__all__ = [
    'CalculationService',
    'fetch_stock_data',
    'fetch_stock_data_batch',
    'fetch_inflation_data',
    'generate_data_points',
    'cache'
]

# Package metadata
PACKAGE_NAME = 'investment_calculator'
DESCRIPTION = 'A tool for calculating and comparing investment growth across multiple stocks'
AUTHOR = __author__
VERSION = __version__

# Configuration defaults
DEFAULT_CACHE_TIMEOUT = 3600  # 1 hour
DEFAULT_INFLATION_RATE = 0.03  # 3% annual inflation
DEFAULT_START_YEAR = 2020
DEFAULT_END_YEAR = 2023

# API configuration
API_RATE_LIMIT = 5  # requests per second
API_TIMEOUT = 30   # seconds

# Feature flags
ENABLE_INFLATION_ADJUSTMENT = True
ENABLE_PERIODIC_INVESTMENTS = True
ENABLE_BATCH_PROCESSING = True

def get_version():
    """Return the current version of the package"""
    return __version__

def get_config():
    """Return the current configuration settings"""
    return {
        'cache_timeout': DEFAULT_CACHE_TIMEOUT,
        'inflation_rate': DEFAULT_INFLATION_RATE,
        'start_year': DEFAULT_START_YEAR,
        'end_year': DEFAULT_END_YEAR,
        'api_rate_limit': API_RATE_LIMIT,
        'api_timeout': API_TIMEOUT,
        'features': {
            'inflation_adjustment': ENABLE_INFLATION_ADJUSTMENT,
            'periodic_investments': ENABLE_PERIODIC_INVESTMENTS,
            'batch_processing': ENABLE_BATCH_PROCESSING
        }
    }

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\cache_service.py ---

from flask_caching import Cache

cache = Cache(config={'CACHE_TYPE': 'simple'})

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\calculation_service.py ---

# services/calculation_service.py
import plotly
import plotly.graph_objs as go
import json
import logging
import pandas as pd
import numpy as np
from .inflation_service import get_inflation_data

logger = logging.getLogger(__name__)

class CalculationService:
    def calculate_investment_growth(self, initial, start_year, end_year, stocks, addition_amount, addition_frequency, adjust_for_inflation):
        logger.info(f"Starting investment growth calculation: initial=${initial}, years={start_year}-{end_year}")
        data = []
        
        # Filter out stocks with no data
        valid_stocks = {}
        for symbol, stock_data in stocks.items():
            if stock_data.isnull().all():
                logger.warning(f"Skipping {symbol} - no valid data found")
                continue
            valid_stocks[symbol] = stock_data
            
        if not valid_stocks:
            raise ValueError("No valid stock data available for calculation")
            
        inflation_data = get_inflation_data() if adjust_for_inflation else None
        logger.info(f"inflation data : {inflation_data}")
        
        for symbol, stock_data in valid_stocks.items():
            current_investment = initial
            last_investment_date = None
            
            # Process data year by year
            for year in range(start_year, end_year + 1):
                yearly_data = stock_data[stock_data.index.year == year]
                if yearly_data.empty:
                    logger.warning(f"No data for {symbol} in year {year}")
                    continue
                
                try:
                    # Get start and end values for the year
                    if year == start_year:
                        start_value = current_investment
                        current_value = current_investment
                    else:
                        start_value = current_value
                    
                    # Calculate returns using daily data
                    daily_return_index = (1 + yearly_data.pct_change()).cumprod()
                    if daily_return_index.iloc[-1] is None or np.isnan(daily_return_index.iloc[-1]):
                        logger.warning(f"Invalid return calculation for {symbol} in year {year}")
                        continue
                        
                    current_value = start_value * daily_return_index.iloc[-1]
                    
                    # Handle periodic investments
                    if addition_frequency == 'monthly':
                        months_in_year = 12 if year > start_year else (13 - yearly_data.index[0].month)
                        addition_total = addition_amount * months_in_year
                        current_investment += addition_total
                        avg_return = daily_return_index.mean()
                        if not np.isnan(avg_return):
                            current_value += addition_total * avg_return
                    
                    elif addition_frequency == 'annually' and year > start_year:
                        current_investment += addition_amount
                        current_value += addition_amount
                    
                    # Apply inflation adjustment if needed
                    if adjust_for_inflation:
                        inflation_rate = inflation_data.get(str(year), 0)
                        logger.info(f"inflationrate for year {year} {inflation_rate}")
                        current_value /= (1 + inflation_rate)
                        current_investment /= (1 + inflation_rate)
                    
                    # Ensure values are valid before adding to data
                    if not (np.isnan(current_value) or np.isnan(current_investment)):
                        data_point = next((d for d in data if d['year'] == year), None)
                        if data_point is None:
                            data_point = {
                                'year': year,
                                'invested': round(current_investment, 2),
                                'total': {},
                                'gains': {}
                            }
                            data.append(data_point)
                        
                        data_point['total'][symbol] = round(current_value, 2)
                        data_point['gains'][symbol] = round(current_value - current_investment, 2)
                        data_point['invested'] = round(current_investment, 2)
                
                except Exception as e:
                    logger.error(f"Error calculating data for {symbol} in year {year}: {str(e)}")
                    continue
        
        # Sort data points by year
        data.sort(key=lambda x: x['year'])
        
        # Validate final data
        if not data:
            raise ValueError("No valid calculation results generated")
            
        logger.info("Investment growth calculation completed")
        return data

    def generate_graph(self, results):
        logger.info("Generating investment growth graph")
        traces = []
        colors = ['blue', 'red', 'green', 'purple', 'orange']
        
        try:
            # Get list of valid symbols (those with non-null data)
            valid_symbols = set()
            for point in results:
                for symbol in point['total'].keys():
                    if point['total'][symbol] is not None and not np.isnan(point['total'][symbol]):
                        valid_symbols.add(symbol)
            
            for i, symbol in enumerate(valid_symbols):
                color = colors[i % len(colors)]
                
                # Filter out null/NaN values
                years = []
                totals = []
                gains = []
                
                for point in results:
                    if symbol in point['total'] and point['total'][symbol] is not None:
                        if not np.isnan(point['total'][symbol]):
                            years.append(point['year'])
                            totals.append(point['total'][symbol])
                            gains.append(point['gains'][symbol])
                
                if years and totals:  # Only create traces if we have valid data
                    trace_total = go.Scatter(
                        x=years,
                        y=totals,
                        mode='lines+markers',
                        name=f'{symbol} (Total)',
                        line=dict(color=color)
                    )
                    
                    trace_gains = go.Scatter(
                        x=years,
                        y=gains,
                        mode='lines',
                        name=f'{symbol} (Gains)',
                        line=dict(color=color, dash='dot')
                    )
                    
                    traces.extend([trace_total, trace_gains])
                    logger.debug(f"Added traces for {symbol}")
            
            # Only add invested trace if we have any valid data
            if traces:
                trace_invested = go.Scatter(
                    x=[point['year'] for point in results],
                    y=[point['invested'] for point in results],
                    mode='lines',
                    name='Invested Amount',
                    line=dict(color='gray', dash='dash')
                )
                traces.append(trace_invested)
            
            layout = go.Layout(
                title='Investment Growth Comparison',
                xaxis={'title': 'Year'},
                yaxis={'title': 'Value ($)'}
            )
            
            if not traces:
                raise ValueError("No valid data to plot")
            
            fig = go.Figure(data=traces, layout=layout)
            return json.dumps(fig, cls=plotly.utils.PlotlyJSONEncoder)
            
        except Exception as e:
            logger.error(f"Error generating graph: {str(e)}")
            raise

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\data_service.py ---

import pandas as pd
from typing import Dict, List
import logging
from .inflation_service import get_inflation_data

logger = logging.getLogger(__name__)

MONTHLY_FREQUENCY = 'monthly'
ANNUALLY_FREQUENCY = 'annually'

import pandas as pd
import logging

logger = logging.getLogger(__name__)

def generate_data_points(initial, start_year, end_year, stocks, addition_amount, addition_frequency, adjust_for_inflation):
    """
    Generate investment data points, removing any NaN values and ensuring clean data.
    """
    logger.info(f"Starting investment growth calculation: initial=${initial}, years={start_year}-{end_year-1}")
    data = []
    inflation_data = get_inflation_data() if adjust_for_inflation else None
    logger.info(f"inflation_data = {inflation_data}")
    for symbol, stock_data in stocks.items():
        monthly_data = []
        current_investment = float(initial)
        current_value = float(initial)
        last_year_processed = None

        # Remove any NaN values and resample to monthly
        stock_data = stock_data.dropna()
        if len(stock_data) == 0:
            continue  # Skip if no valid data after removing NaN
            
        monthly_stock_data = stock_data.resample('ME').last().dropna()
        
        # Skip if no valid monthly data
        if len(monthly_stock_data) == 0:
            continue
            
        for date in monthly_stock_data.index:
            year = int(date.year)
            month = int(date.month)
            
            if year < start_year or year >= end_year:
                continue

            # Get start price, ensuring it's not NaN
            start_price = float(stock_data.iloc[0])
            current_price = float(monthly_stock_data.loc[date])
            
            # Skip if either price is invalid
            if pd.isna(start_price) or pd.isna(current_price):
                continue
                
            cumulative_return = (current_price / start_price) - 1
            current_value = initial * (1 + cumulative_return)
            
            # Handle periodic investments
            if addition_frequency == 'monthly' and (year > start_year or month > 1):
                current_investment += addition_amount
                if month > 1 or year > start_year:
                    prev_date = date - pd.DateOffset(months=1)
                    # Only calculate additional return if we have valid previous data
                    if prev_date in stock_data.index and not pd.isna(stock_data.loc[prev_date]):
                        addition_start_price = float(stock_data.loc[prev_date])
                        addition_return = (current_price / addition_start_price) - 1
                        current_value += addition_amount * (1 + addition_return)
                    else:
                        # If no valid previous data, just add the amount without return
                        current_value += addition_amount
            
            elif addition_frequency == 'annually' and month == 1 and year > start_year:
                current_investment += addition_amount
                current_value += addition_amount

            # Apply inflation adjustment yearly (in December)
            if adjust_for_inflation and inflation_data and str(year) in inflation_data:
                # Only apply inflation adjustment once per year (in December)
                if month == 12 and year != last_year_processed:
                    annual_inflation = float(inflation_data[str(year)])
                    logger.info(
                        f"Applying yearly inflation adjustment for {year}:\n"
                        f"  Annual inflation rate: {annual_inflation:.4f} ({annual_inflation*100:.2f}%)\n"
                        f"  Before adjustment: value=${current_value:.2f}"
                    )
                    
                    # Apply annual inflation adjustment
                    current_value *= (1 - annual_inflation)
                    
                    logger.info(
                        f"  After adjustment: value=${current_value:.2f}\n"
                        f"  Value decrease due to inflation: ${(current_value / (1 - annual_inflation) - current_value):.2f}"
                    )
                    last_year_processed = year
            
            gains = current_value - current_investment
            
            # Skip if any calculations resulted in NaN
            if any(pd.isna(x) for x in [current_value, current_investment, gains]):
                continue
                
            return_percentage = (gains / current_investment) * 100 if current_investment != 0 else 0
            
            monthly_data.append({
                "year": year,
                "month": month,
                "date": date.strftime("%Y-%m"),
                "invested": round(float(current_investment), 2),
                "total": round(float(current_value), 2),
                "gains": round(float(gains), 2),
                "return_percentage": round(float(return_percentage), 2)
            })

        # Only add to results if we have valid monthly data
        if monthly_data:
            data.append({
                "symbol": symbol,
                "monthly_data": monthly_data
            })
    
    logger.info("Investment growth calculation completed")
    return data


def _should_add_investment(frequency: str, date: pd.Timestamp, year: int, start_year: int) -> bool:
    if frequency == MONTHLY_FREQUENCY:
        return date.day == 1 and not (year == start_year and date.month == 1)
    elif frequency == ANNUALLY_FREQUENCY:
        return date.month == 1 and date.day == 1 and year != start_year
    return False

def _calculate_new_value(stock_data: pd.Series, current_date: pd.Timestamp, current_value: float) -> float:
    price = stock_data.loc[current_date]
    next_date = current_date + pd.Timedelta(days=1)
    if next_date in stock_data.index:
        next_price = stock_data.loc[next_date]
        growth_factor = next_price / price
        return current_value * growth_factor
    return current_value

def _create_yearly_data_point(year: int, invested: float, total: float) -> Dict:
    gains = total - invested
    return {
        "year": year,
        "invested": float(round(invested, 2)),
        "total": float(round(total, 2)),
        "gains": float(round(gains, 2)),
        "return_percentage": float(round((gains / invested) * 100, 2))
    }

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\inflation_service.py ---

# services/inflation_service.py
import json
import os
from flask import current_app

def get_inflation_data():
    """Get historical inflation data"""
    try:
        file_path = os.path.join(current_app.config['DATA_DIR'], 'inflation_data.json')
        with open(file_path, 'r') as f:
            data = json.load(f)
            return data['US']  # Or allow country selection in the future
    except Exception as e:
        current_app.logger.error(f"Error loading inflation data: {str(e)}")
        return None

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\stock_list_service.py ---

import json
import os
from flask import current_app

def load_stock_data():
    """Load stock data from JSON file"""
    try:
        file_path = os.path.join(current_app.config['DATA_DIR'], 'stock_list.json')
        with open(file_path, 'r') as f:
            data = json.load(f)
            return data['stocks']
    except Exception as e:
        current_app.logger.error(f"Error loading stock data: {str(e)}")
        return []

def get_stock_list():
    return load_stock_data()

def search_stocks(query):
    """Search stocks by symbol or name"""
    stocks = load_stock_data()
    query = query.lower()
    return [
        stock for stock in stocks
        if query in stock['symbol'].lower() or query in stock['name'].lower()
    ]

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\stock_service.py ---

import yfinance as yf
import pandas as pd
from .cache_service import cache
import logging

import yfinance as yf
import pandas as pd
from .cache_service import cache
import logging

logger = logging.getLogger(__name__)

@cache.memoize(timeout=3600)  # Cache for 1 hour
def fetch_stock_data_batch(symbols, start_year, end_year):
    """
    Fetch historical data for multiple stock symbols, handling NaN values appropriately.
    """
    logger.info(f"Fetching batch stock data for symbols: {symbols}")
    
    start_date = f"{start_year}-01-01"
    end_date = f"{end_year}-12-31"
    
    try:
        symbols_str = " ".join(symbols)
        data = yf.download(
            tickers=symbols_str,
            start=start_date,
            end=end_date,
            interval="1d",
            group_by='ticker',
            auto_adjust=True
        )
        
        logger.debug(f"Downloaded data length: {len(data)}")
        
        result = {}
        invalid_symbols = []
        data_issues = {}
        
        # Handle single stock case
        if len(symbols) == 1:
            symbol = symbols[0]
            if isinstance(data, pd.DataFrame) and not data['Close'].isnull().all():
                close_data = data['Close'].dropna()  # Remove NaN values
                if len(close_data) > 0:  # Only include if we have valid data
                    result[symbol] = close_data
                    result[symbol].index = pd.to_datetime(result[symbol].index.date)
                    logger.debug(f"Processed single stock data for {symbol}")
                else:
                    invalid_symbols.append(symbol)
                    data_issues[symbol] = {
                        'status': 'no_data',
                        'error': 'No valid data points found'
                    }
            else:
                invalid_symbols.append(symbol)
                data_issues[symbol] = {
                    'status': 'no_data',
                    'error': 'Invalid or missing data'
                }
            
        # Handle multiple stocks case
        else:
            for symbol in symbols:
                try:
                    if symbol in data.columns.levels[0]:
                        stock_data = data[symbol]['Close'].dropna()  # Remove NaN values
                        
                        # Calculate data quality metrics
                        total_original = len(data[symbol]['Close'])
                        valid_points = len(stock_data)
                        null_points = total_original - valid_points
                        
                        if valid_points > 0:  # If we have any valid points
                            result[symbol] = stock_data
                            result[symbol].index = pd.to_datetime(result[symbol].index.date)
                            
                            # Record data quality information
                            if null_points > 0:
                                data_issues[symbol] = {
                                    'total_points': int(total_original),
                                    'valid_points': int(valid_points),
                                    'null_points': int(null_points),
                                    'null_percentage': float((null_points/total_original) * 100),
                                    'first_valid_date': stock_data.index[0].strftime('%Y-%m-%d'),
                                    'last_valid_date': stock_data.index[-1].strftime('%Y-%m-%d'),
                                    'status': 'partial_data'
                                }
                        else:
                            invalid_symbols.append(symbol)
                            data_issues[symbol] = {
                                'total_points': int(total_original),
                                'valid_points': 0,
                                'null_points': int(total_original),
                                'status': 'no_valid_data'
                            }
                    else:
                        invalid_symbols.append(symbol)
                        data_issues[symbol] = {
                            'status': 'no_data',
                            'error': 'Symbol not found in data'
                        }
                except Exception as e:
                    invalid_symbols.append(symbol)
                    data_issues[symbol] = {
                        'status': 'error',
                        'error': str(e)
                    }

        logger.info(f"Successfully fetched data for {len(result)} stocks")
        logger.info(f"Data issues found: {data_issues}")
        logger.info(f"Invalid symbols: {invalid_symbols}")
        
        return result, invalid_symbols, data_issues
        
    except Exception as e:
        logger.error(f"Error fetching batch stock data: {str(e)}")
        return {}, symbols, {}


--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\visualization_service.py ---

# services/visualization_service.py
import plotly
import plotly.graph_objs as go
import json
import logging

logger = logging.getLogger(__name__)


class VisualizationService:
    @staticmethod
    def generate_graph(results):
        logger.info("Generating investment growth graph")
        traces = []
        colors = ['blue', 'red', 'green', 'purple', 'orange']

        for i, stock_data in enumerate(results):
            symbol = stock_data['symbol']
            color = colors[i % len(colors)]
            
            monthly_data = stock_data['monthly_data']
            x_values = [point['date'] for point in monthly_data]
            y_values = [point['total'] for point in monthly_data]
            
            # Create the main line trace with markers
            trace_total = go.Scatter(
                x=x_values,
                y=y_values,
                mode='lines+markers',  # Removed text to avoid crowding with monthly points
                name=f'{symbol} Total',
                line=dict(color=color),
                hovertemplate='%{x}<br>Value: $%{y:,.2f}<extra></extra>'
            )
            
            # Create trace for invested amount
            invested_values = [point['invested'] for point in monthly_data]
            trace_invested = go.Scatter(
                x=x_values,
                y=invested_values,
                mode='lines+markers',
                name='Invested Amount',
                line=dict(color='gray', dash='dash'),
                hovertemplate='%{x}<br>Invested: $%{y:,.2f}<extra></extra>'
            )
            
            traces.extend([trace_total, trace_invested])
            logger.debug(f"Added traces for {symbol}")

        # Get min and max dates from the data
        all_dates = [point['date'] for stock in results for point in stock['monthly_data']]
        min_date = min(all_dates) if all_dates else None
        max_date = max(all_dates) if all_dates else None

        layout = go.Layout(
            title='Investment Growth Comparison',
            xaxis={
                'title': 'Date',
                'tickformat': '%Y-%m',  # Show as YYYY-MM
                'tickangle': -45,  # Angle the dates for better readability
                'nticks': 12,  # Show approximately monthly ticks
            },
            yaxis={
                'title': 'Value ($)',
                'tickformat': '$,.0f',
                'rangemode': 'tozero'  # Start y-axis from 0
            },
            hovermode='x unified',
            showlegend=True,
            legend={
                'orientation': 'h',
                'yanchor': 'bottom',
                'y': 1.02,
                'xanchor': 'right',
                'x': 1
            },
            margin=dict(t=100, b=80),  # Increased bottom margin for angled labels
            plot_bgcolor='white',
            paper_bgcolor='white',
        )

        fig = go.Figure(data=traces, layout=layout)
        
        # Add gridlines
        fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='#f0f0f0')
        fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='#f0f0f0')
        
        logger.info("Graph generation completed")
        return json.dumps(fig, cls=plotly.utils.PlotlyJSONEncoder)

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\__init__.py ---

# services/__init__.py
from .cache_service import cache
from .stock_service import fetch_stock_data_batch
from .data_service import generate_data_points
from .calculation_service import CalculationService
from .visualization_service import VisualizationService
from.inflation_service import get_inflation_data

__all__ = [
    'cache',
    'fetch_stock_data_batch',
    'generate_data_points',
    'CalculationService',
    'VisualizationService',
    'get_inflation_data'
]

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\data\inflation_data.json ---

{
    "US": {
        "1970": 0.056,
        "1971": 0.040,
        "1972": 0.032,
        "1973": 0.061,
        "1974": 0.110,
        "1975": 0.091,
        "1976": 0.058,
        "1977": 0.065,
        "1978": 0.079,
        "1979": 0.113,
        "1980": 0.136,
        "1981": 0.106,
        "1982": 0.061,
        "1983": 0.032,
        "1984": 0.042,
        "1985": 0.035,
        "1986": 0.019,
        "1987": 0.036,
        "1988": 0.040,
        "1989": 0.048,
        "1990": 0.053,
        "1991": 0.042,
        "1992": 0.030,
        "1993": 0.030,
        "1994": 0.026,
        "1995": 0.028,
        "1996": 0.030,
        "1997": 0.023,
        "1998": 0.016,
        "1999": 0.021,
        "2000": 0.034,
        "2001": 0.028,
        "2002": 0.016,
        "2003": 0.022,
        "2004": 0.027,
        "2005": 0.034,
        "2006": 0.032,
        "2007": 0.028,
        "2008": 0.038,
        "2009": -0.004,
        "2010": 0.016,
        "2011": 0.031,
        "2012": 0.020,
        "2013": 0.015,
        "2014": 0.016,
        "2015": 0.001,
        "2016": 0.013,
        "2017": 0.021,
        "2018": 0.024,
        "2019": 0.018,
        "2020": 0.012,
        "2021": 0.047,
        "2022": 0.081,
        "2023": 0.041
    }
}


--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\services\data\stock_list.json ---

{
    "stocks": [
        {"symbol": "AAPL", "name": "Apple Inc."},
        {"symbol": "MSFT", "name": "Microsoft Corporation"},
        {"symbol": "GOOG", "name": "Alphabet Inc."},
        {"symbol": "AMZN", "name": "Amazon.com Inc."},
        {"symbol": "META", "name": "Meta Platforms Inc."},
        {"symbol": "TSLA", "name": "Tesla Inc."},
        {"symbol": "NVDA", "name": "NVIDIA Corporation"},
        {"symbol": "JPM", "name": "JPMorgan Chase & Co."},
        {"symbol": "JNJ", "name": "Johnson & Johnson"},
        {"symbol": "V", "name": "Visa Inc."},
        {"symbol": "WMT", "name": "Walmart Inc."},
        {"symbol": "PG", "name": "Procter & Gamble Co."},
        {"symbol": "MA", "name": "Mastercard Inc."},
        {"symbol": "HD", "name": "Home Depot Inc."},
        {"symbol": "BAC", "name": "Bank of America Corp."},
        {"symbol": "DIS", "name": "Walt Disney Co."},
        {"symbol": "ADBE", "name": "Adobe Inc."},
        {"symbol": "NFLX", "name": "Netflix Inc."},
        {"symbol": "XOM", "name": "Exxon Mobil Corporation"},
        {"symbol": "CSCO", "name": "Cisco Systems Inc."},
        {"symbol": "VOO", "name": "Vanguard S&P 500 ETF"},
        {"symbol": "VTI", "name": "Vanguard Total Stock Market ETF"},
        {"symbol": "QQQ", "name": "Invesco QQQ Trust"},
        {"symbol": "SPY", "name": "SPDR S&P 500 ETF Trust"},
        {"symbol": "VEA", "name": "Vanguard FTSE Developed Markets ETF"},
        {"symbol": "BND", "name": "Vanguard Total Bond Market ETF"},
        {"symbol": "VWO", "name": "Vanguard FTSE Emerging Markets ETF"},
        {"symbol": "IWM", "name": "iShares Russell 2000 ETF"},
        {"symbol": "INTC", "name": "Intel Corporation"},
        {"symbol": "KO", "name": "The Coca-Cola Company"},
        {"symbol": "PEP", "name": "PepsiCo Inc."},
        {"symbol": "MRK", "name": "Merck & Co. Inc."},
        {"symbol": "VZ", "name": "Verizon Communications Inc."},
        {"symbol": "COST", "name": "Costco Wholesale Corporation"},
        {"symbol": "AMD", "name": "Advanced Micro Devices Inc."}
    ]
}

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\styles.css ---

/* Base styles */
body {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    margin: 0;
    padding: 0;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    color: #333;
    margin-bottom: 30px;
}

/* Form elements */
.form-group {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
}

input[type="number"],
input[type="text"],
select {
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    background-color: white;
}

input[type="number"],
input[type="text"] {
    width: 200px;
}

/* Buttons */
button {
    padding: 12px 24px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

button:hover:not(:disabled) {
    opacity: 0.9;
    transform: translateY(-1px);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

button.calculate {
    background-color: #2ecc71;
    color: white;
}

button.remove-stock {
    background-color: transparent;
    color: #e74c3c;
    padding: 8px;
}

.button-group {
    display: flex;
    gap: 10px;
    margin: 20px 0;
}

/* Stock Search */
.stock-search-container {
    margin-bottom: 20px;
    position: relative;
    max-width: 400px;
}

.stock-search {
    width: 100%;
    padding: 12px;
}

.stock-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 1000;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

/* Stock Items */
.selected-stocks {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 20px;
}

.stock-item {
    position: relative;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 12px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

.stock-info {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.stock-header {
    display: flex;
    align-items: center;
    gap: 10px;
}

.stock-symbol {
    font-weight: bold;
    color: #2c3e50;
}

.stock-name {
    color: #666;
    font-size: 0.9em;
}

/* Status Indicators */
.status-indicator {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.85em;
    margin-left: 8px;
}

/* Error and Warning States */
.error-badge {
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
    background-color: #e74c3c;
    color: white;
    border-radius: 12px;
    font-size: 0.75em;
    margin-left: 8px;
}

.stock-error,
.stock-warning {
    font-size: 0.9em;
    margin-top: 5px;
    padding: 4px 8px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.stock-error {
    color: #e74c3c;
    background-color: #fdf2f2;
}

.stock-warning {
    color: #f39c12;
    background-color: #fef9e7;
}

.stock-error::before,
.stock-warning::before {
    content: "⚠️";
}

/* State Classes */
.stock-item.has-error {
    border-left: 3px solid #e74c3c;
    background-color: #fff5f5;
}

.stock-item.has-warning {
    border-left: 3px solid #f39c12;
    background-color: #fef9e7;
}

/* Custom Stock Styles */
.stock-item.custom-stock {
    border-left: 3px solid #2ecc71;
}

.stock-item.custom-stock.has-error {
    border-left: 3px solid #e74c3c;
}

.custom-label {
    font-size: 0.9em;
    color: #2ecc71;
    display: flex;
    align-items: center;
    gap: 5px;
}

.custom-label::before {
    content: '＋';
    font-weight: bold;
}

/* Results Display */
.graph-results-container {
    margin-top: 30px;
    display: flex;
    flex-direction: column;
    gap: 30px;
}

#graph {
    width: 100%;
    min-height: 500px;
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.results-section {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    overflow: hidden;
}

/* Table Styles */
.table-container {
    overflow-x: auto;
}

table {
    width: 100%;
    border-collapse: collapse;
}

th {
    background: #3498db;
    color: white;
    padding: 12px 15px;
    text-align: left;
    font-weight: 500;
    white-space: nowrap;
    position: sticky;
    top: 0;
}

td {
    padding: 12px 15px;
    border-bottom: 1px solid #eee;
}

.value-cell {
    text-align: right;
    font-family: monospace;
}

.positive-value { color: #27ae60; }
.negative-value { color: #e74c3c; }

/* Loading States */
.loading-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background: rgba(255,255,255,0.9);
    border-radius: 8px;
    margin: 20px 0;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

/* Animations */
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Utility Classes */
.hidden {
    display: none !important;
}

/* Value cell styling */
.value-cell {
    text-align: right;
    font-family: monospace;
    font-weight: 500;
    transition: background-color 0.2s ease;
}

/* Positive values (gains) */
.value-cell.positive-value {
    color: #22c55e; /* Bright green */
}

/* Negative values (losses) */
.value-cell.negative-value {
    color: #dc2626; /* Bright red */
}

/* Percentage changes */
.percent-change {
    display: inline-flex;
    align-items: center;
}

.percent-change.positive::before {
    content: "▲";
    margin-right: 4px;
    color: #22c55e;
}

.percent-change.negative::before {
    content: "▼";
    margin-right: 4px;
    color: #dc2626;
}

/* Table row hover effect */
tr:hover td {
    background-color: #f8fafc;
}

/* Results section styling */
.results-section {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-top: 20px;
}

.results-header {
    padding: 16px 20px;
    border-bottom: 1px solid #eee;
}

.results-header h2 {
    margin: 0;
    color: #2c3e50;
    font-size: 1.25rem;
}

/* Table container */
.table-container {
    overflow-x: auto;
    padding: 0;
}

/* Table styling */
table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
}

th {
    background: #3498db;
    color: white;
    padding: 12px 16px;
    text-align: left;
    font-weight: 500;
    position: sticky;
    top: 0;
}

td {
    padding: 12px 16px;
    border-bottom: 1px solid #eee;
    white-space: nowrap;
}

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\calculator.js ---

// State management
let stocksList = [];
let selectedStocks = new Set();

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeForm();
    initializeStockSearch();
    setupEventListeners();
    addErrorStyles();
});

// Setup and Initialization
function initializeForm() {
    const currentYear = new Date().getFullYear();
    document.getElementById('endYear').value = currentYear;
    document.getElementById('startYear').value = currentYear - 5;
    document.getElementById('initialInvestment').value = 10000;
    document.getElementById('additionAmount').value = 0;
}

function setupEventListeners() {
    // Form submission
    document.getElementById('calculatorForm').addEventListener('submit', function(e) {
        e.preventDefault();
        calculate();
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.stock-search-wrapper')) {
            document.querySelector('.stock-dropdown')?.classList.add('hidden');
        }
    });

    // Year validation
    ['startYear', 'endYear'].forEach(id => {
        document.getElementById(id).addEventListener('change', validateYearInputs);
    });
}

// Stock Search and Management
async function initializeStockSearch() {
    try {
        const searchInput = document.querySelector('.stock-search');
        searchInput.addEventListener('input', debounce(handleSearchInput, 200));
        
        const response = await fetch('/api/stocks');
        stocksList = await response.json();
    } catch (error) {
        console.error('Error initializing stock search:', error);
        displayError('Failed to load stocks list. Please refresh the page.');
    }
}

async function handleSearchInput(e) {
    const query = e.target.value.trim().toUpperCase();
    const dropdown = document.querySelector('.stock-dropdown');
    
    if (!query) {
        dropdown.classList.add('hidden');
        return;
    }

    try {
        // First search in known stocks
        let matchingStocks = stocksList.filter(stock => 
            stock.symbol.includes(query) || 
            stock.name.toUpperCase().includes(query)
        );

        // Always add option to use custom stock if input looks like a valid symbol
        if (/^[A-Z0-9.]{1,10}$/.test(query) && !matchingStocks.find(s => s.symbol === query)) {
            matchingStocks.push({
                symbol: query,
                name: 'Custom Stock Symbol',
                isCustom: true
            });
        }

        displaySearchResults(matchingStocks);
    } catch (error) {
        console.error('Error searching stocks:', error);
    }
}

function displaySearchResults(results) {
    const dropdown = document.querySelector('.stock-dropdown');
    dropdown.innerHTML = '';

    if (results.length === 0) {
        dropdown.innerHTML = '<div class="stock-option">No results found</div>';
    } else {
        // First show known stocks
        const knownStocks = results.filter(stock => !stock.isCustom);
        if (knownStocks.length > 0) {
            knownStocks.forEach(stock => {
                if (!selectedStocks.has(stock.symbol)) {
                    addStockOption(stock, dropdown);
                }
            });
        }

        // Then show custom stock option if exists
        const customStock = results.find(stock => stock.isCustom);
        if (customStock) {
            // Add separator if we had known stocks
            if (knownStocks.length > 0) {
                const separator = document.createElement('div');
                separator.className = 'stock-separator';
                separator.textContent = 'Custom Stock';
                dropdown.appendChild(separator);
            }
            addStockOption(customStock, dropdown, true);
        }
    }
    dropdown.classList.remove('hidden');
}

// Helper function to add stock option to dropdown
function addStockOption(stock, dropdown, isCustom = false) {
    const option = document.createElement('div');
    option.className = `stock-option ${isCustom ? 'custom-stock' : ''}`;
    option.innerHTML = `
        <div class="stock-info">
            <span class="stock-symbol">${stock.symbol}</span>
            ${isCustom ? 
                `<span class="custom-label">Add Custom Stock</span>` : 
                `<span class="stock-name">${stock.name}</span>`
            }
        </div>
    `;
    option.addEventListener('click', () => addStock(stock));
    dropdown.appendChild(option);
}


function removeStock(symbol) {
    if (selectedStocks.size <= 1) {
        displayError("You must have at least one stock.");
        return;
    }
    
    selectedStocks.delete(symbol);
    const stockElement = document.getElementById(`stock-${symbol}`);
    if (stockElement) {
        stockElement.remove();
    }
}

function clearSearch() {
    const searchInput = document.querySelector('.stock-search');
    searchInput.value = '';
    document.querySelector('.stock-dropdown').classList.add('hidden');
}

// Calculation and Results
async function calculate() {
    if (!validateForm()) return;

    clearError();
    showLoading();
    clearResults();

    try {
        const formData = getFormData();
        const response = await fetch('/calculate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formData)
        });

        if (!response.ok) {
            throw new Error(`Server error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.errors) {
            displayErrors(data.errors);
        } else if (data.error) {
            displayError(data.error);
        } else if (data.data && Array.isArray(data.data)) {
            createPlot(data.data);
            displayResults(data.data);
        } else {
            throw new Error('Invalid response from server');
        }
    } catch (error) {
        console.error('Error during calculation:', error);
        displayError(`Calculation failed: ${error.message}`);
    } finally {
        hideLoading();
    }
}

function createPlot(data) {
    const traces = [];
    const colors = ['#2E86C1', '#E74C3C', '#2ECC71', '#F1C40F', '#9B59B6'];

    data.forEach((stockData, index) => {
        const timeData = stockData.monthly_data || stockData.yearly_data;
        if (!timeData) return;

        traces.push({
            x: timeData.map(point => point.date || point.year),
            y: timeData.map(point => point.total),
            mode: 'lines+markers',
            name: `${stockData.symbol} Total`,
            line: {color: colors[index % colors.length], width: 2},
            marker: {size: 6},
            hovertemplate: '%{x}<br>Value: $%{y:,.2f}<extra></extra>'
        });

        // Only add invested amount line once
        if (index === 0) {
            traces.push({
                x: timeData.map(point => point.date || point.year),
                y: timeData.map(point => point.invested),
                mode: 'lines',
                name: 'Invested Amount',
                line: {color: '#95A5A6', dash: 'dash', width: 2},
                hovertemplate: '%{x}<br>Invested: $%{y:,.2f}<extra></extra>'
            });
        }
    });

    const layout = {
        title: {
            text: 'Investment Growth Comparison',
            font: {size: 24}
        },
        xaxis: {
            title: 'Date',
            tickangle: -45,
            tickformat: '%Y-%m',
            gridcolor: '#E0E0E0'
        },
        yaxis: {
            title: 'Value ($)',
            tickformat: '$,.0f',
            rangemode: 'tozero',
            gridcolor: '#E0E0E0'
        },
        hovermode: 'x unified',
        showlegend: true,
        legend: {
            orientation: 'h',
            yanchor: 'bottom',
            y: 1.02,
            xanchor: 'right',
            x: 1
        },
        margin: {t: 100, b: 80, l: 80, r: 40},
        plot_bgcolor: 'white',
        paper_bgcolor: 'white',
        font: {family: 'Arial, sans-serif'}
    };

    Plotly.newPlot('graph', traces, layout, {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d']
    });
}

function displayResults(data) {
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = `
        <div class="results-section">
            <div class="results-header">
                <h2>Investment Results</h2>
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Stock</th>
                            <th>Total Value</th>
                            <th>Invested Amount</th>
                            <th>Gains</th>
                            <th>Return (%)</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    `;

    const tbody = resultsDiv.querySelector('tbody');
    
    data.forEach(stockData => {
        const timeData = stockData.monthly_data || stockData.yearly_data;
        if (!timeData) return;

        timeData.forEach(point => {
            const row = document.createElement('tr');
            const gains = point.total - point.invested;
            row.innerHTML = `
                <td>${point.date || point.year}</td>
                <td>${stockData.symbol}</td>
                <td class="value-cell">${formatCurrency(point.total)}</td>
                <td class="value-cell">${formatCurrency(point.invested)}</td>
                <td class="value-cell ${gains >= 0 ? 'positive-value' : 'negative-value'}">
                    ${formatCurrency(gains)}
                </td>
                <td class="value-cell ${point.return_percentage >= 0 ? 'positive-value' : 'negative-value'}">
                    ${point.return_percentage.toFixed(2)}%
                </td>
            `;
            tbody.appendChild(row);
        });
    });
}

// Utility Functions
function validateForm() {
    const form = document.getElementById('calculatorForm');
    if (!form.checkValidity()) {
        form.reportValidity();
        return false;
    }
    return validateYearInputs();
}

function validateYearInputs() {
    const startYear = parseInt(document.getElementById('startYear').value);
    const endYear = parseInt(document.getElementById('endYear').value);
    const currentYear = new Date().getFullYear();

    if (startYear > endYear) {
        displayError('Start year must be before end year');
        return false;
    }

    if (startYear < 1970) {
        displayError('Start year must be 1970 or later');
        return false;
    }

    if (endYear > currentYear + 1) {
        displayError(`End year cannot be more than ${currentYear + 1}`);
        return false;
    }

    return true;
}

function getFormData() {
    return {
        initialInvestment: parseFloat(document.getElementById('initialInvestment').value),
        startYear: parseInt(document.getElementById('startYear').value),
        endYear: parseInt(document.getElementById('endYear').value),
        additionAmount: parseFloat(document.getElementById('additionAmount').value),
        additionFrequency: document.getElementById('additionFrequency').value,
        adjustForInflation: document.getElementById('adjustForInflation').checked,
        stocks: Array.from(selectedStocks)
    };
}

function formatCurrency(value) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).format(value);
}

function showLoading() {
    document.getElementById('loading').classList.remove('hidden');
    document.querySelector('button[type="submit"]').disabled = true;
}

function hideLoading() {
    document.getElementById('loading').classList.add('hidden');
    document.querySelector('button[type="submit"]').disabled = false;
}

function clearResults() {
    document.getElementById('graph').innerHTML = '';
    document.getElementById('results').innerHTML = '';
}

function displayError(message) {
    const errorContainer = document.getElementById('errorContainer');
    const errorText = document.getElementById('errorText');
    const graphDiv = document.getElementById('graph');
    const resultsDiv = document.getElementById('results');
    
    // Show error message
    errorText.textContent = message;
    errorContainer.classList.remove('hidden');
    
    // Clear results
    graphDiv.innerHTML = '';
    resultsDiv.innerHTML = '';
}

function clearError() {
    document.getElementById('errorContainer').classList.add('hidden');
}

function displayErrors(errors) {
    // First, hide all error messages
    document.querySelectorAll('.stock-input .error-message').forEach(msg => {
        msg.textContent = '';
        msg.classList.add('hidden');
    });

    // Display new error messages
    Object.entries(errors).forEach(([symbol, error]) => {
        const stockInput = Array.from(document.querySelectorAll('.stock-input'))
            .find(div => div.querySelector('input').value === symbol);
        if (stockInput) {
            const errorSpan = stockInput.querySelector('.error-message');
            errorSpan.textContent = error;
            errorSpan.classList.remove('hidden');
        }
    });
}


function displayErrors2(errors) {
    // Clear any previous global error
    clearError();
    
    Object.entries(errors).forEach(([symbol, error]) => {
        // Get the stock element
        const stockElement = document.getElementById(`stock-${symbol}`);
        if (stockElement) {
            stockElement.classList.add('has-error');
            
            // Add or update error message
            let errorDiv = stockElement.querySelector('.stock-error');
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.className = 'stock-error';
                stockElement.appendChild(errorDiv);
            }

            // Make error message more user-friendly
            let userFriendlyError = formatErrorMessage(error);
            errorDiv.textContent = userFriendlyError;
        }
    });
}

// Add a function to format error messages
function formatErrorMessage(error) {
    // Check for common error patterns and convert to user-friendly messages
    if (error.includes('Unexpected token') || error.includes('not valid JSON')) {
        return 'Invalid stock symbol. This stock may not exist or is not available for trading.';
    }
    if (error.includes('No data available')) {
        return 'No trading data available for this stock in the selected date range.';
    }
    
    // For custom stocks that don't exist
    if (error.toLowerCase().includes('not found') || error.toLowerCase().includes('invalid')) {
        return 'This stock symbol could not be found. Please verify the symbol is correct.';
    }

    // Default case
    return error;
}

// Update the error display styles
function addErrorStyles() {
    const style = document.createElement('style');
    style.textContent = `
        .stock-error {
            color: #e74c3c;
            font-size: 0.9em;
            margin-top: 5px;
            padding: 5px 10px;
            background-color: #fdf2f2;
            border-radius: 4px;
            display: block;
        }

        .stock-item.has-error {
            border-left: 3px solid #e74c3c;
            background-color: #fff5f5;
        }

        .stock-item.has-error .stock-symbol {
            color: #e74c3c;
        }
    `;
    document.head.appendChild(style);
}

function addStock(stock) {
    if (selectedStocks.has(stock.symbol)) return;

    selectedStocks.add(stock.symbol);
    const stockList = document.querySelector('.selected-stocks');
    
    // Remove any existing error states
    const existingError = document.querySelector(`#stock-${stock.symbol}`);
    if (existingError) {
        existingError.classList.remove('has-error');
        const errorMessage = existingError.querySelector('.stock-error');
        if (errorMessage) {
            errorMessage.remove();
        }
    }

    const stockElement = document.createElement('div');
    stockElement.className = `stock-item ${stock.isCustom ? 'custom-stock' : ''}`;
    stockElement.id = `stock-${stock.symbol}`;
    stockElement.innerHTML = `
        <div class="stock-info">
            <span class="stock-symbol">${stock.symbol}</span>
            <span class="stock-name">
                ${stock.isCustom ? 'Custom Stock Symbol' : stock.name}
                ${stock.isCustom ? '<span class="custom-indicator">(Custom)</span>' : ''}
            </span>
        </div>
        <button type="button" class="remove-stock" onclick="removeStock('${stock.symbol}')" title="Remove stock">
            <i class="fas fa-trash"></i>
        </button>
    `;
    
    stockList.appendChild(stockElement);
    clearSearch();
}


function displayStockError(symbol, error) {
    const stockElement = document.getElementById(`stock-${symbol}`);
    if (stockElement) {
        stockElement.classList.add('has-error');
        let errorDiv = stockElement.querySelector('.stock-error');
        if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.className = 'stock-error';
            stockElement.appendChild(errorDiv);
        }
        errorDiv.textContent = error;
    }
}

function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\main.js ---

// static/js/main.js
import { APIService } from './services/api.js';
import { ValidationService } from './services/validation.js';
import { FormatterService } from './services/formatter.js';
import { VisualizationService } from './services/visualization.js';
import { StockManager } from './components/stockManager.js';
import { ResultsTable } from './components/resultsTable.js';
import { LoggerService } from './services/logger.js';

class InvestmentCalculator {
    constructor() {
        LoggerService.info('InvestmentCalculator', 'Initializing calculator');
        
        // Initialize properties
        this.stockManager = new StockManager();
        this.boundMethods = this.bindMethods();
        
        // Start initialization
        this.initializeApplication();
    }

    bindMethods() {
        LoggerService.debug('InvestmentCalculator', 'Binding class methods');
        
        // Bind all methods that need 'this' context
        this.handleCalculation = this.handleCalculation.bind(this);
        this.handleSearchInput = this.handleSearchInput.bind(this);
        this.validateYearInputs = this.validateYearInputs.bind(this);
        this.hideDropdown = this.hideDropdown.bind(this);
        this.displaySearchResults = this.displaySearchResults.bind(this);
        this.addStock = this.addStock.bind(this);
        this.removeStock = this.removeStock.bind(this);
        this.displayError = this.displayError.bind(this);
        this.clearError = this.clearError.bind(this);
        this.clearSearch = this.clearSearch.bind(this);
    }

    async initializeApplication() {
        try {
            await this.stockManager.initialize();
            this.initializeForm();
            this.setupEventListeners();
            LoggerService.info('InvestmentCalculator', 'Application initialized successfully');
        } catch (error) {
            LoggerService.error('InvestmentCalculator', 'Failed to initialize application', error);
            this.displayError('Failed to initialize calculator. Please refresh the page.');
        }
    }

    initializeForm() {
        LoggerService.debug('InvestmentCalculator', 'Initializing form');
        try {
            const currentYear = new Date().getFullYear();
            const elements = {
                endYear: currentYear,
                startYear: currentYear - 5,
                initialInvestment: '10000',
                additionAmount: '0'
            };

            Object.entries(elements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.value = value;
                } else {
                    LoggerService.warn('InvestmentCalculator', `Form element not found: ${id}`);
                }
            });
        } catch (error) {
            LoggerService.error('InvestmentCalculator', 'Form initialization failed', error);
            throw error;
        }
    }

    setupEventListeners() {
        LoggerService.debug('InvestmentCalculator', 'Setting up event listeners');

        // Form submission
        const form = document.getElementById('calculatorForm');
        if (form) {
            form.addEventListener('submit', this.handleCalculation);
        }

        // Search input
        const searchInput = document.querySelector('.stock-search');
        if (searchInput) {
            const debouncedSearch = this.debounce((e) => this.handleSearchInput(e), 200);
            searchInput.addEventListener('input', debouncedSearch);
        }

        // Year validation
        ['startYear', 'endYear'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', this.validateYearInputs);
            }
        });

        // Dropdown close
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.stock-search-wrapper')) {
                this.hideDropdown();
            }
        });

        LoggerService.info('InvestmentCalculator', 'Event listeners setup completed');
    }

    async handleSearchInput(event) {
        const query = event.target.value.trim();
        LoggerService.debug('InvestmentCalculator', 'Search input received', { query });

        if (!query) {
            this.hideDropdown();
            return;
        }

        try {
            const results = await this.stockManager.searchStocks(query);
            this.displaySearchResults(results);
        } catch (error) {
            LoggerService.error('InvestmentCalculator', 'Search operation failed', {
                query,
                error: error.message
            });
            this.displayError('Failed to search stocks');
        }
    }

    displaySearchResults(results) {
        LoggerService.debug('InvestmentCalculator', 'Displaying search results', { resultCount: results.length });
        
        const dropdown = document.querySelector('.stock-dropdown');
        if (!dropdown) {
            LoggerService.error('InvestmentCalculator', 'Dropdown element not found');
            return;
        }

        dropdown.innerHTML = '';

        if (results.length === 0) {
            dropdown.innerHTML = '<div class="stock-option">No results found</div>';
        } else {
            results.forEach(stock => {
                if (!this.stockManager.selectedStocks.has(stock.symbol)) {
                    this.addStockOption(stock, dropdown);
                }
            });
        }

        dropdown.classList.remove('hidden');
    }

    addStockOption(stock, dropdown) {
        const option = document.createElement('div');
        option.className = `stock-option ${stock.isCustom ? 'custom-stock' : ''}`;
        option.innerHTML = `
            <div class="stock-info">
                <span class="stock-symbol">${stock.symbol}</span>
                ${stock.isCustom ? 
                    `<span class="custom-label">Add Custom Stock</span>` : 
                    `<span class="stock-name">${stock.name}</span>`
                }
            </div>
        `;
        option.addEventListener('click', () => this.addStock(stock));
        dropdown.appendChild(option);
    }

    displayResults(data) {
        LoggerService.debug('InvestmentCalculator', 'Displaying results', data);
        
        const resultsDiv = document.getElementById('results');
        if (!resultsDiv) {
            LoggerService.error('InvestmentCalculator', 'Results container not found');
            return;
        }

        resultsDiv.innerHTML = '';

        // Clear all previous warnings first
        this.clearAllWarnings();

        // Display warnings if present
        if (data.warnings) {
            this.displayWarnings(data.warnings);
        }

        const table = ResultsTable.create(data.data);
        resultsDiv.appendChild(table);
    }

    clearAllWarnings() {
        // Clear warnings from all stock items
        document.querySelectorAll('.stock-warning').forEach(warning => {
            warning.textContent = '';
            warning.classList.add('hidden');
        });
        // Clear any warning highlights
        document.querySelectorAll('.stock-item').forEach(item => {
            item.classList.remove('has-warning');
        });
    }


    displayStockWarning(symbol, warning) {
        const stockElement = document.getElementById(`stock-${symbol}`);
        if (!stockElement) {
            LoggerService.warn('InvestmentCalculator', 'Stock element not found for warning', {
                symbol,
                warning
            });
            return;
        }

        const warningElement = stockElement.querySelector('.stock-warning');
        if (warningElement) {
            // Format the warning message based on the warning data structure
            let warningMessage = '';
            if (typeof warning === 'object') {
                if (warning.status === 'all_null' || warning.status === 'no_valid_data') {
                    warningMessage = 'Invalid symbol or no data available';
                } else if (warning.status === 'partial_data' && warning.first_valid_date) {
                    const startYear = warning.first_valid_date.split('-')[0];
                    warningMessage = `Data available since ${startYear}`;
                } else if (warning.error) {
                    warningMessage = warning.error;
                } else {
                    warningMessage = `Unknown error occurred, error status: ${warning.status}`;
                }
            } else {
                warningMessage = String(warning); // Convert to string in case it's not already
            }

            warningElement.textContent = warningMessage;
            warningElement.classList.remove('hidden');
            stockElement.classList.add('has-warning');

            LoggerService.debug('InvestmentCalculator', 'Warning displayed for stock', {
                symbol,
                warningMessage
            });
        }
    }

    displayWarnings(warnings) {
        LoggerService.debug('InvestmentCalculator', 'Processing warnings', warnings);
    
        const { invalidSymbols = [], dataIssues = {}, dateRangeIssues = [] } = warnings;
    
        // Handle invalid symbols and data issues together
        invalidSymbols.forEach(symbol => {
            const issue = dataIssues[symbol] || { status: 'no_data', error: 'Symbol not found' };
            this.displayStockWarning(symbol, issue);
        });
    
        // Handle any remaining data issues for valid symbols
        Object.entries(dataIssues).forEach(([symbol, issue]) => {
            if (!invalidSymbols.includes(symbol)) {
                this.displayStockWarning(symbol, issue);
            }
        });
    
        // Handle date range issues (if any)
        if (dateRangeIssues.length > 0) {
            this.displayDateRangeWarning(dateRangeIssues);
        }
    }


    removeStock(symbol) {
        LoggerService.debug('InvestmentCalculator', 'Removing stock', { symbol });
        
        const result = this.stockManager.removeStock(symbol);
        if (result.success) {
            const stockElement = document.getElementById(`stock-${symbol}`);
            if (stockElement) {
                stockElement.remove();
            }
        } else {
            this.displayError(result.error);
        }
    }

    async handleCalculation(event) {
        event.preventDefault();
        this.clearError();
        
        // Clear previous graph and results
        const graphDiv = document.getElementById('graph');
        const resultsDiv = document.getElementById('results');
        if (graphDiv) graphDiv.innerHTML = '';
        if (resultsDiv) resultsDiv.innerHTML = '';
        
        const startTime = LoggerService.startTimer();
        
        LoggerService.info('InvestmentCalculator', 'Starting calculation process');
    
        try {
            const formData = this.getFormData();
            const validation = ValidationService.validateFormInputs(formData); // Rename/modify to only check basic inputs
            
            if (!validation.isValid) {
                LoggerService.warn('InvestmentCalculator', 'Form validation failed', validation.errors);
                this.displayErrors(validation.errors);
                return;
            }
    
            this.showLoading();
            const result = await APIService.calculateInvestment(formData);
    
            // If we got data, display it regardless of warnings
            if (result.data) {
                const plotConfig = VisualizationService.createPlotConfig(result.data);
                await Plotly.newPlot('graph', plotConfig.traces, plotConfig.layout, {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d']
                });
                this.displayResults(result);
            }
    
            // Display any warnings, but don't treat them as errors
            if (result.warnings) {
                this.displayWarnings(result.warnings);
            }
    
            LoggerService.endTimer(startTime, 'InvestmentCalculator', 'calculation');
    
        } catch (error) {
            LoggerService.error('InvestmentCalculator', 'Calculation failed', error);
            this.displayError(FormatterService.formatErrorMessage(error));
        } finally {
            this.hideLoading();
        }
    }
    
    displayWarnings(warnings) {
        LoggerService.debug('InvestmentCalculator', 'Processing warnings', warnings);
    
        const { invalidSymbols = [], dataIssues = {}, dateRangeIssues = [] } = warnings;
    
        // Handle invalid symbols and data issues together
        invalidSymbols.forEach(symbol => {
            const issue = dataIssues[symbol] || 'Symbol not found';
            this.displayStockWarning(symbol, issue);
        });
    
        // Handle any remaining data issues for valid symbols
        Object.entries(dataIssues).forEach(([symbol, issue]) => {
            if (!invalidSymbols.includes(symbol)) {
                this.displayStockWarning(symbol, issue);
            }
        });
    
        // Handle date range issues (if any)
        if (dateRangeIssues.length > 0) {
            this.displayDateRangeWarning(dateRangeIssues);
        }
    }

    addStock(stock) {
        LoggerService.debug('InvestmentCalculator', 'Adding stock', stock);
        
        if (this.stockManager.addStock(stock)) {
            const stockList = document.querySelector('.selected-stocks');
            if (!stockList) {
                LoggerService.error('InvestmentCalculator', 'Stock list element not found');
                return;
            }

            const stockElement = document.createElement('div');
            stockElement.className = `stock-item ${stock.isCustom ? 'custom-stock' : ''}`;
            stockElement.id = `stock-${stock.symbol}`;
            
            stockElement.innerHTML = `
                <div class="stock-info">
                    <div class="stock-header">
                        <span class="stock-symbol">${stock.symbol}</span>
                        <span class="stock-name">${stock.isCustom ? 'Custom Stock Symbol' : stock.name}</span>
                    </div>
                    <div class="stock-warning hidden"></div>
                </div>
                <button type="button" class="remove-stock" title="Remove stock">
                    <i class="fas fa-trash"></i>
                </button>
            `;

            const removeButton = stockElement.querySelector('.remove-stock');
            removeButton.addEventListener('click', () => this.removeStock(stock.symbol));
            
            stockList.appendChild(stockElement);
            this.clearSearch();
        }
    }


    displayError(message) {
        LoggerService.debug('InvestmentCalculator', 'Displaying error', { message });
        
        const errorContainer = document.getElementById('errorContainer');
        const errorText = document.getElementById('errorText');
        
        if (errorContainer && errorText) {
            errorText.textContent = message;
            errorContainer.classList.remove('hidden');
        } else {
            LoggerService.error('InvestmentCalculator', 'Error container elements not found');
        }
    }

    displayErrors(errors) {
        const errorContainer = document.getElementById('errorContainer');
        const errorText = document.getElementById('errorText');
        
        if (errorContainer && errorText) {
            errorText.innerHTML = errors.map(error => `<div>${error}</div>`).join('');
            errorContainer.classList.remove('hidden');
        }
    }

    clearError() {
        const errorContainer = document.getElementById('errorContainer');
        if (errorContainer) {
            errorContainer.classList.add('hidden');
        }
    }

    showLoading() {
        document.getElementById('loading')?.classList.remove('hidden');
        document.querySelector('button[type="submit"]')?.setAttribute('disabled', 'true');
    }

    hideLoading() {
        document.getElementById('loading')?.classList.add('hidden');
        document.querySelector('button[type="submit"]')?.removeAttribute('disabled');
    }

    clearSearch() {
        const searchInput = document.querySelector('.stock-search');
        if (searchInput) {
            searchInput.value = '';
        }
        this.hideDropdown();
    }

    hideDropdown() {
        const dropdown = document.querySelector('.stock-dropdown');
        if (dropdown) {
            dropdown.classList.add('hidden');
        }
    }

    validateYearInputs() {
        const startYear = parseInt(document.getElementById('startYear')?.value);
        const endYear = parseInt(document.getElementById('endYear')?.value);
        
        const validation = ValidationService.validateYearInputs(startYear, endYear);
        if (!validation.isValid) {
            this.displayError(validation.error);
            return false;
        }
        
        this.clearError();
        return true;
    }

    getFormData() {
        return {
            initialInvestment: parseFloat(document.getElementById('initialInvestment')?.value || '0'),
            startYear: parseInt(document.getElementById('startYear')?.value || '0'),
            endYear: parseInt(document.getElementById('endYear')?.value || '0'),
            additionAmount: parseFloat(document.getElementById('additionAmount')?.value || '0'),
            additionFrequency: document.getElementById('additionFrequency')?.value || 'none',
            adjustForInflation: document.getElementById('adjustForInflation')?.checked || false,
            stocks: Array.from(this.stockManager.selectedStocks)
        };
    }

    debounce(func, wait) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                LoggerService.debug('InvestmentCalculator', 'Debounced function executed');
                func.apply(this, args);
            }, wait);
        };
    }
}

// Initialize the calculator when the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.calculator = new InvestmentCalculator();
});

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\stockCore.js ---

class StockCore {
    constructor() {
        this.stocksList = [];
        this.selectedStocks = new Set();
    }

    validateYearInputs(startYear, endYear) {
        const currentYear = new Date().getFullYear();

        if (startYear > endYear) {
            return {
                isValid: false,
                error: 'Start year must be before end year'
            };
        }

        if (startYear < 1970) {
            return {
                isValid: false,
                error: 'Start year must be 1970 or later'
            };
        }

        if (endYear > currentYear + 1) {
            return {
                isValid: false,
                error: `End year cannot be more than ${currentYear + 1}`
            };
        }

        return { isValid: true };
    }

    validateStockData(stockData, startYear, endYear) {
        if (!stockData || stockData.empty) {
            return {
                isValid: false,
                error: "No data available for this symbol"
            };
        }

        const firstDate = new Date(stockData.index[0]);
        const lastDate = new Date(stockData.index[stockData.index.length - 1]);
        const firstYear = firstDate.getFullYear();
        const lastYear = lastDate.getFullYear();

        if (startYear < firstYear) {
            return {
                isValid: false,
                error: `Data only available from ${firstYear}`
            };
        }

        if (endYear > lastYear + 1) {
            return {
                isValid: false,
                error: `Data only available until ${lastYear}`
            };
        }

        return { isValid: true };
    }

    addStock(stock) {
        if (this.selectedStocks.has(stock.symbol)) return false;
        this.selectedStocks.add(stock.symbol);
        return true;
    }

    removeStock(symbol) {
        if (this.selectedStocks.size <= 1) {
            return {
                success: false,
                error: "You must have at least one stock."
            };
        }
        
        this.selectedStocks.delete(symbol);
        return { success: true };
    }

    formatCurrency(value) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(value);
    }

    formatErrorMessage(error) {
        if (error.includes('Unexpected token') || error.includes('not valid JSON')) {
            return 'Invalid stock symbol. This stock may not exist or is not available for trading.';
        }
        if (error.includes('No data available')) {
            return 'No trading data available for this stock in the selected date range.';
        }
        if (error.toLowerCase().includes('not found') || error.toLowerCase().includes('invalid')) {
            return 'This stock symbol could not be found. Please verify the symbol is correct.';
        }
        return error;
    }

    createPlotConfig(data) {
        const colors = ['#2E86C1', '#E74C3C', '#2ECC71', '#F1C40F', '#9B59B6'];
        const traces = [];

        data.forEach((stockData, index) => {
            const timeData = stockData.monthly_data || stockData.yearly_data;
            if (!timeData) return;

            traces.push({
                x: timeData.map(point => point.date || point.year),
                y: timeData.map(point => point.total),
                mode: 'lines+markers',
                name: `${stockData.symbol} Total`,
                line: {color: colors[index % colors.length], width: 2},
                marker: {size: 6},
                hovertemplate: '%{x}<br>Value: $%{y:,.2f}<extra></extra>'
            });

            if (index === 0) {
                traces.push({
                    x: timeData.map(point => point.date || point.year),
                    y: timeData.map(point => point.invested),
                    mode: 'lines',
                    name: 'Invested Amount',
                    line: {color: '#95A5A6', dash: 'dash', width: 2},
                    hovertemplate: '%{x}<br>Invested: $%{y:,.2f}<extra></extra>'
                });
            }
        });

        return {
            traces,
            layout: {
                title: {
                    text: 'Investment Growth Comparison',
                    font: {size: 24}
                },
                xaxis: {
                    title: 'Date',
                    tickangle: -45,
                    tickformat: '%Y-%m',
                    gridcolor: '#E0E0E0'
                },
                yaxis: {
                    title: 'Value ($)',
                    tickformat: '$,.0f',
                    rangemode: 'tozero',
                    gridcolor: '#E0E0E0'
                },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: 1.02,
                    xanchor: 'right',
                    x: 1
                },
                margin: {t: 100, b: 80, l: 80, r: 40},
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                font: {family: 'Arial, sans-serif'}
            }
        };
    }
}

const stockCore = new StockCore();
window.stockCore = stockCore; // Make available globally

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\stockUI.js ---

import { stockCore } from './stockCore.js';

class StockUI {
    constructor() {
        this.initializeEventListeners();
    }

    // Initialization methods
    initializeEventListeners() {
        document.addEventListener('DOMContentLoaded', () => {
            this.initializeForm();
            this.initializeStockSearch();
            this.setupFormListeners();
            this.setupSearchListeners();
        });
    }

    initializeForm() {
        const currentYear = new Date().getFullYear();
        document.getElementById('endYear').value = currentYear;
        document.getElementById('startYear').value = currentYear - 5;
        document.getElementById('initialInvestment').value = 10000;
        document.getElementById('additionAmount').value = 0;
    }

    async initializeStockSearch() {
        try {
            const searchInput = document.querySelector('.stock-search');
            searchInput.addEventListener('input', this.debounce(this.handleSearchInput.bind(this), 200));
            
            const response = await fetch('/api/stocks');
            stockCore.stocksList = await response.json();
        } catch (error) {
            console.error('Error initializing stock search:', error);
            this.displayError('Failed to load stocks list. Please refresh the page.');
        }
    }

    setupFormListeners() {
        document.getElementById('calculatorForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleCalculation();
        });

        ['startYear', 'endYear'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => this.validateYearInputs());
        });
    }

    // UI Event Handlers
    async handleCalculation() {
        if (!this.validateForm()) return;

        this.clearAllErrors();
        this.showLoading();
        this.clearResults();

        try {
            const formData = this.getFormData();
            const response = await fetch('/calculate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            });

            const data = await response.json();
            
            if (data.errors) {
                this.handleErrors(data.errors, formData.stocks);
                return;
            }

            if (data.warnings) {
                this.handleWarnings(data.warnings);
            }

            if (data.data && data.graph) {
                this.displayResults(data);
            }
        } catch (error) {
            console.error('Error during calculation:', error);
            this.displayError(stockCore.formatErrorMessage(error.message));
        } finally {
            this.hideLoading();
        }
    }

    async handleSearchInput(event) {
        const query = event.target.value.trim().toUpperCase();
        if (!query) {
            this.hideDropdown();
            return;
        }

        const matchingStocks = this.findMatchingStocks(query);
        this.displaySearchResults(matchingStocks);
    }

    // UI Display Methods
    displaySearchResults(results) {
        const dropdown = document.querySelector('.stock-dropdown');
        dropdown.innerHTML = '';

        if (results.length === 0) {
            dropdown.innerHTML = '<div class="stock-option">No results found</div>';
        } else {
            this.renderStockOptions(results, dropdown);
        }
        
        dropdown.classList.remove('hidden');
    }

    displayResults(data) {
        const { traces, layout } = stockCore.createPlotConfig(data.data);
        Plotly.newPlot('graph', traces, layout, {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['lasso2d', 'select2d']
        });

        this.renderResultsTable(data.data);
    }

    addStock(stock) {
        if (!stockCore.addStock(stock)) return; // Use core logic

        const stockList = document.querySelector('.selected-stocks');
        const stockElement = document.createElement('div');
        stockElement.className = 'stock-item';
        stockElement.id = `stock-${stock.symbol}`;

        stockElement.innerHTML = `
            <div class="stock-info">
                <div class="stock-header">
                    <span class="stock-symbol">${stock.symbol}</span>
                    <span class="stock-name">${stock.isCustom ? 'Custom Stock Symbol' : stock.name}</span>
                </div>
                <div class="stock-error hidden"></div>
            </div>
            <button 
                type="button" 
                class="remove-stock" 
                onclick="stockUI.removeStock('${stock.symbol}')" 
                title="Remove stock">
                <i class="fas fa-trash"></i>
            </button>
        `;
        
        stockList.appendChild(stockElement);
        this.clearSearch();
    }

    // Helper Methods
    renderStockOptions(results, dropdown) {
        const knownStocks = results.filter(stock => !stock.isCustom);
        const customStock = results.find(stock => stock.isCustom);

        knownStocks.forEach(stock => {
            if (!stockCore.selectedStocks.has(stock.symbol)) {
                this.addStockOption(stock, dropdown);
            }
        });

        if (customStock) {
            this.addCustomStockOption(customStock, dropdown, knownStocks.length > 0);
        }
    }

    renderResultsTable(data) {
        // Implementation of results table rendering
        // ... (existing implementation)
    }

    // Utility Methods
    debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    getFormData() {
        return {
            initialInvestment: parseFloat(document.getElementById('initialInvestment').value),
            startYear: parseInt(document.getElementById('startYear').value),
            endYear: parseInt(document.getElementById('endYear').value),
            additionAmount: parseFloat(document.getElementById('additionAmount').value),
            additionFrequency: document.getElementById('additionFrequency').value,
            adjustForInflation: document.getElementById('adjustForInflation').checked,
            stocks: Array.from(stockCore.selectedStocks)
        };
    }
}

// Initialize the UI
const stockUI = new StockUI();

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\components\resultsTable.js ---

import { FormatterService } from '../services/formatter.js';

export class ResultsTable {
    static create(data) {
        const table = document.createElement('table');
        table.className = 'results-table';
        
        // Create table header
        const thead = document.createElement('thead');
        thead.innerHTML = `
            <tr>
                <th>Date</th>
                <th>Stock</th>
                <th>Total Value</th>
                <th>Invested Amount</th>
                <th>Gains/Losses</th>
                <th>Return (%)</th>
            </tr>
        `;
        table.appendChild(thead);

        // Create table body
        const tbody = document.createElement('tbody');
        data.forEach(stockData => {
            const timeData = stockData.monthly_data || stockData.yearly_data;
            if (!timeData) return;

            timeData.forEach(point => {
                const row = document.createElement('tr');
                const gains = point.total - point.invested;
                const isPositive = gains >= 0;
                
                row.innerHTML = `
                    <td>${point.date || point.year}</td>
                    <td>${stockData.symbol}</td>
                    <td class="value-cell">${FormatterService.formatCurrency(point.total)}</td>
                    <td class="value-cell">${FormatterService.formatCurrency(point.invested)}</td>
                    <td class="value-cell ${isPositive ? 'positive-value' : 'negative-value'}">
                        <span class="percent-change ${isPositive ? 'positive' : 'negative'}">
                            ${FormatterService.formatCurrency(Math.abs(gains))}
                        </span>
                    </td>
                    <td class="value-cell ${point.return_percentage >= 0 ? 'positive-value' : 'negative-value'}">
                        <span class="percent-change ${point.return_percentage >= 0 ? 'positive' : 'negative'}">
                            ${FormatterService.formatPercentage(point.return_percentage)}
                        </span>
                    </td>
                `;
                tbody.appendChild(row);
            });
        });
        table.appendChild(tbody);

        // Wrap table in container
        const container = document.createElement('div');
        container.className = 'results-section';
        container.innerHTML = `
            <div class="results-header">
                <h2>Investment Results</h2>
            </div>
        `;
        
        const tableContainer = document.createElement('div');
        tableContainer.className = 'table-container';
        tableContainer.appendChild(table);
        container.appendChild(tableContainer);

        return container;
    }
}

class ResultsTablee {
    static create(data) {
        const table = document.createElement('table');
        table.className = 'results-table';
        
        const headers = ['Date', 'Stock', 'Total Value', 'Invested Amount', 'Gains', 'Return (%)'];
        const thead = document.createElement('thead');
        thead.innerHTML = `<tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>`;
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        data.forEach(stockData => {
            const timeData = stockData.monthly_data || stockData.yearly_data;
            if (!timeData) return;

            timeData.forEach(point => {
                const row = document.createElement('tr');
                const gains = point.total - point.invested;
                row.innerHTML = `
                    <td>${point.date || point.year}</td>
                    <td>${stockData.symbol}</td>
                    <td class="value-cell">${FormatterService.formatCurrency(point.total)}</td>
                    <td class="value-cell">${FormatterService.formatCurrency(point.invested)}</td>
                    <td class="value-cell ${gains >= 0 ? 'positive' : 'negative'}">
                        ${FormatterService.formatCurrency(gains)}
                    </td>
                    <td class="value-cell ${point.return_percentage >= 0 ? 'positive' : 'negative'}">
                        ${FormatterService.formatPercentage(point.return_percentage)}
                    </td>
                `;
                tbody.appendChild(row);
            });
        });
        table.appendChild(tbody);

        return table;
    }
}

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\components\stockManager.js ---

import { APIService } from '../services/api.js';

export class StockManager {
    constructor() {
        this.selectedStocks = new Set();
        this.stocksList = [];
    }

    async initialize() {
        try {
            this.stocksList = await APIService.fetchStocks();
        } catch (error) {
            console.error('Failed to initialize stock list:', error);
            throw error;
        }
    }

    addStock(stock) {
        if (this.selectedStocks.has(stock.symbol)) return false;
        this.selectedStocks.add(stock.symbol);
        return true;
    }

    removeStock(symbol) {
        if (this.selectedStocks.size <= 1) {
            return { success: false, error: "You must have at least one stock." };
        }
        this.selectedStocks.delete(symbol);
        return { success: true };
    }

    async searchStocks(query) {
        if (!query.trim()) return [];
        
        const uppercaseQuery = query.toUpperCase();
        let results = this.stocksList.filter(stock => 
            stock.symbol.includes(uppercaseQuery) || 
            stock.name.toUpperCase().includes(uppercaseQuery)
        );

        if (/^[A-Z0-9.]{1,10}$/.test(uppercaseQuery) && 
            !results.find(s => s.symbol === uppercaseQuery)) {
            results.push({
                symbol: uppercaseQuery,
                name: 'Custom Stock Symbol',
                isCustom: true
            });
        }

        return results;
    }
}


--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\services\api.js ---

// static/js/services/APIService.js
import { LoggerService } from './logger.js';

export class APIService {
    static API_ENDPOINTS = {
        STOCKS_LIST: '/api/stocks',
        STOCKS_SEARCH: '/api/stocks/search',
        CALCULATE: '/calculate',
        INFLATION: '/api/inflation'
    };

    static ERROR_TYPES = {
        INVALID_INPUT: 'INVALID_INPUT',
        INVALID_DATE_RANGE: 'INVALID_DATE_RANGE',
        NO_STOCK_DATA: 'NO_STOCK_DATA',
        CALCULATION_ERROR: 'CALCULATION_ERROR',
        VISUALIZATION_ERROR: 'VISUALIZATION_ERROR',
        DATA_PROCESSING_ERROR: 'DATA_PROCESSING_ERROR',
        SERVER_ERROR: 'SERVER_ERROR',
        NETWORK_ERROR: 'NETWORK_ERROR'
    };

    static API_TIMEOUT = 30000; // 30 seconds

    /**
     * Fetches the list of available stocks
     * Corresponds to /api/stocks endpoint
     */
    static async fetchStocks() {
        const startTime = LoggerService.startTimer();
        LoggerService.info('APIService', 'Fetching stock list');

        try {
            const response = await this.fetchWithTimeout(this.API_ENDPOINTS.STOCKS_LIST);
            const data = await response.json();

            if (!response.ok) {
                if (response.status === 400) {
                    throw this.createError(data, this.ERROR_TYPES.INVALID_INPUT);
                } else if (response.status === 404) {
                    throw this.createError(data, this.ERROR_TYPES.NO_STOCK_DATA);
                } else if (response.status === 500) {
                    throw this.createError(data, this.ERROR_TYPES.SERVER_ERROR);
                } else {
                    throw this.createError(data, this.ERROR_TYPES.DATA_PROCESSING_ERROR);
                }
            }

            LoggerService.info('APIService', 'Successfully fetched stock list', {
                stockCount: data.length,
                duration: LoggerService.endTimer(startTime, 'APIService', 'fetchStocks')
            });

            return data;

        } catch (error) {
            LoggerService.error('APIService', 'Failed to fetch stocks', {
                error: error.message,
                type: error.type,
                details: error.details,
                status: error.status
            });
            throw error;
        }
    }

    /**
     * Fetches inflation data
     * Corresponds to /api/inflation endpoint
     */
    static async fetchInflationData() {
        const startTime = LoggerService.startTimer();
        LoggerService.info('APIService', 'Fetching inflation data');

        try {
            const response = await this.fetchWithTimeout(this.API_ENDPOINTS.INFLATION);
            const data = await response.json();

            if (!response.ok) {
                throw this.createError(data, this.ERROR_TYPES.DATA_PROCESSING_ERROR);
            }

            LoggerService.info('APIService', 'Successfully fetched inflation data', {
                yearsCount: Object.keys(data).length,
                duration: LoggerService.endTimer(startTime, 'APIService', 'fetchInflationData')
            });

            return data;

        } catch (error) {
            LoggerService.error('APIService', 'Failed to fetch inflation data', {
                error: error.message,
                type: error.type,
                details: error.details
            });
            throw error;
        }
    }

    /**
     * Searches for stocks based on query
     * Corresponds to /api/stocks/search endpoint
     */
    static async searchStocks(query) {
        const startTime = LoggerService.startTimer();
        LoggerService.info('APIService', 'Searching stocks', { query });

        if (!query?.trim()) {
            LoggerService.debug('APIService', 'Empty search query, returning empty results');
            return [];
        }

        try {
            const url = `${this.API_ENDPOINTS.STOCKS_SEARCH}?q=${encodeURIComponent(query)}`;
            const response = await this.fetchWithTimeout(url);
            const data = await response.json();

            if (!response.ok) {
                throw this.createError(data, this.ERROR_TYPES.DATA_PROCESSING_ERROR);
            }

            LoggerService.info('APIService', 'Stock search completed', {
                query,
                resultsCount: data.length,
                duration: LoggerService.endTimer(startTime, 'APIService', 'searchStocks')
            });

            return data;

        } catch (error) {
            LoggerService.error('APIService', 'Stock search failed', {
                query,
                error: error.message,
                type: error.type,
                details: error.details
            });
            throw error;
        }
    }

    /**
     * Calculates investment returns
     * Corresponds to /calculate endpoint
     */
    static async calculateInvestment(data) {
        const startTime = LoggerService.startTimer();
        LoggerService.info('APIService', 'Starting investment calculation', {
            stocks: data.stocks,
            startYear: data.startYear,
            endYear: data.endYear
        });
    
        try {
            // Only validate for critical errors, not dates
            this.validateCalculationInput(data);
    
            const response = await this.fetchWithTimeout(
                this.API_ENDPOINTS.CALCULATE,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                }
            );
    
            const result = await response.json();
    
            // Simplified error handling - only handle true errors
            if (!response.ok) {
                if (response.status === 400 && result.details?.invalidSymbols) {
                    // Handle invalid symbols as warnings, not errors
                    result.warnings = result.warnings || {};
                    result.warnings.invalidSymbols = result.details.invalidSymbols;
                    
                    // If we have any valid symbols, continue
                    if (result.data) {
                        LoggerService.warn('APIService', 'Some symbols were invalid', {
                            invalidSymbols: result.details.invalidSymbols
                        });
                    } else {
                        throw this.createError(result, this.ERROR_TYPES.NO_STOCK_DATA);
                    }
                } else if (response.status === 500) {
                    throw this.createError(result, this.ERROR_TYPES.SERVER_ERROR);
                } else {
                    throw this.createError(result, this.ERROR_TYPES.DATA_PROCESSING_ERROR);
                }
            }
    
            // Log any warnings
            if (result.warnings) {
                LoggerService.warn('APIService', 'Calculation completed with warnings', {
                    warnings: result.warnings,
                    stocks: data.stocks
                });
            }
    
            LoggerService.info('APIService', 'Investment calculation completed', {
                stockCount: data.stocks.length,
                duration: LoggerService.endTimer(startTime, 'APIService', 'calculateInvestment'),
                hasWarnings: !!result.warnings
            });
    
            return result;
    
        } catch (error) {
            LoggerService.error('APIService', 'Investment calculation failed', {
                data,
                error: error.message,
                type: error.type,
                details: error.details
            });
            throw error;
        }
    }

    /**
     * Validates calculation input data
     */
    static validateCalculationInput(data) {
        if (!data.stocks?.length) {
            throw this.createError(
                { error: 'No stocks provided', details: 'At least one stock must be selected' },
                this.ERROR_TYPES.INVALID_INPUT
            );
        }

        if (data.endYear <= data.startYear) {
            throw this.createError(
                { error: 'Invalid date range', details: 'End year must be greater than start year' },
                this.ERROR_TYPES.INVALID_DATE_RANGE
            );
        }

        if (data.initialInvestment < 0) {
            throw this.createError(
                { error: 'Invalid investment amount', details: 'Initial investment cannot be negative' },
                this.ERROR_TYPES.INVALID_INPUT
            );
        }

        if (data.additionAmount < 0) {
            throw this.createError(
                { error: 'Invalid addition amount', details: 'Additional investment amount cannot be negative' },
                this.ERROR_TYPES.INVALID_INPUT
            );
        }

        LoggerService.debug('APIService', 'Calculation input validation passed', data);
    }

    /**
     * Creates a standardized error object
     */
    static createError(response, type) {
        const error = new Error(response.error || 'An unexpected error occurred');
        error.type = type;
        error.details = response.details || {};
        return error;
    }

    /**
     * Fetches with timeout
     */
    static async fetchWithTimeout(url, options = {}) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.API_TIMEOUT);

        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            return response;
        } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
                throw this.createError(
                    { error: 'Request timeout', details: 'The request took too long to complete' },
                    this.ERROR_TYPES.NETWORK_ERROR
                );
            }
            throw this.createError(
                { error: 'Network error', details: error.message },
                this.ERROR_TYPES.NETWORK_ERROR
            );
        }
    }

    /**
     * Handles error responses
     */
    static async handleErrorResponse(response) {
        let errorData;
        try {
            errorData = await response.json();
        } catch {
            errorData = {
                error: 'Unknown error',
                details: 'Failed to parse error response'
            };
        }

        return errorData;
    }
}

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\services\formatter.js ---

export class FormatterService {
    static formatCurrency(value) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(value);
    }

    static formatPercentage(value) {
        return new Intl.NumberFormat('en-US', {
            style: 'percent',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(value / 100);
    }

    static formatErrorMessage(error) {
        if (typeof error === 'string') {
            if (error.includes('Unexpected token') || error.includes('not valid JSON')) {
                return 'Invalid stock symbol. This stock may not exist or is not available for trading.';
            }
            if (error.includes('No data available')) {
                return 'No trading data available for this stock in the selected date range.';
            }
            if (error.toLowerCase().includes('not found') || error.toLowerCase().includes('invalid')) {
                return 'This stock symbol could not be found. Please verify the symbol is correct.';
            }
        }
        return error?.message || error?.toString() || 'An unknown error occurred';
    }
}

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\services\logger.js ---

// static/js/services/LoggerService.js

export class LoggerService {
    static LOG_LEVELS = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
    };

    // Check if we're in development mode by looking for common development indicators
    static isDevelopment() {
        return window.location.hostname === 'localhost' || 
               window.location.hostname === '127.0.0.1' ||
               window.location.hostname.includes('local');
    }

    static currentLogLevel = this.isDevelopment() 
        ? this.LOG_LEVELS.DEBUG 
        : this.LOG_LEVELS.INFO;

    static formatMessage(level, context, message, data) {
        const timestamp = new Date().toISOString();
        let dataString = '';
        
        try {
            dataString = data ? JSON.stringify(data, this.safeStringify) : '';
        } catch (e) {
            dataString = '[Unstringifiable data]';
        }
        
        return `[${timestamp}] [${level}] [${context}] ${message} ${dataString}`.trim();
    }

    static safeStringify(key, value) {
        if (value instanceof Error) {
            return {
                message: value.message,
                stack: value.stack,
                ...Object.fromEntries(
                    Object.getOwnPropertyNames(value)
                        .map(prop => [prop, value[prop]])
                )
            };
        }
        if (typeof value === 'bigint') {
            return value.toString();
        }
        if (value instanceof Set) {
            return Array.from(value);
        }
        if (value instanceof Map) {
            return Object.fromEntries(value);
        }
        if (typeof value === 'function') {
            return '[Function]';
        }
        if (value instanceof Date) {
            return value.toISOString();
        }
        return value;
    }

    static debug(context, message, data = null) {
        if (this.currentLogLevel <= this.LOG_LEVELS.DEBUG) {
            console.debug(this.formatMessage('DEBUG', context, message, data));
        }
    }

    static info(context, message, data = null) {
        if (this.currentLogLevel <= this.LOG_LEVELS.INFO) {
            console.info(this.formatMessage('INFO', context, message, data));
        }
    }

    static warn(context, message, data = null) {
        if (this.currentLogLevel <= this.LOG_LEVELS.WARN) {
            console.warn(this.formatMessage('WARN', context, message, data));
        }
    }

    static error(context, message, error = null) {
        if (this.currentLogLevel <= this.LOG_LEVELS.ERROR) {
            console.error(this.formatMessage('ERROR', context, message, error));
        }
    }

    // Performance monitoring
    static startTimer() {
        return performance.now();
    }

    static endTimer(startTime, context, operation) {
        const duration = performance.now() - startTime;
        this.debug(context, `Operation timing: ${operation}`, { duration: `${duration}ms` });
        return duration;
    }

    static setLogLevel(level) {
        if (this.LOG_LEVELS.hasOwnProperty(level)) {
            this.currentLogLevel = this.LOG_LEVELS[level];
            this.debug('LoggerService', `Log level set to ${level}`);
        }
    }

    // Additional utility methods
    static getStackTrace() {
        try {
            throw new Error();
        } catch (e) {
            return e.stack.split('\n').slice(2).join('\n');
        }
    }

    static group(context, label) {
        if (this.currentLogLevel <= this.LOG_LEVELS.DEBUG) {
            console.group(`[${context}] ${label}`);
        }
    }

    static groupEnd() {
        if (this.currentLogLevel <= this.LOG_LEVELS.DEBUG) {
            console.groupEnd();
        }
    }

    static table(context, data, columns = null) {
        if (this.currentLogLevel <= this.LOG_LEVELS.DEBUG) {
            console.log(`[${context}] Table data:`);
            console.table(data, columns);
        }
    }

    // Environment detection
    static getEnvironment() {
        return {
            isDevelopment: this.isDevelopment(),
            userAgent: navigator.userAgent,
            timestamp: new Date().toISOString(),
            viewport: {
                width: window.innerWidth,
                height: window.innerHeight
            }
        };
    }
}

// Initialize with debug mode if in development
if (LoggerService.isDevelopment()) {
    LoggerService.debug('LoggerService', 'Initialized in development mode', 
        LoggerService.getEnvironment());
}

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\services\validation.js ---

export class ValidationService {
    static validateYearInputs(startYear, endYear) {
        const currentYear = new Date().getFullYear();
        
        if (startYear > endYear) {
            return { isValid: false, error: 'Start year must be before end year' };
        }
        
        if (startYear < 1970) {
            return { isValid: false, error: 'Start year must be 1970 or later' };
        }
        
        if (endYear > currentYear + 1) {
            return { isValid: false, error: `End year cannot be more than ${currentYear + 1}` };
        }
        
        return { isValid: true };
    }

    static validateFormInputs(formData) {
        const errors = [];
        
        if (formData.initialInvestment < 0) {
            errors.push('Initial investment cannot be negative');
        }
        
        if (formData.additionAmount < 0) {
            errors.push('Additional investment amount cannot be negative');
        }
        
        if (formData.stocks.length === 0) {
            errors.push('At least one stock must be selected');
        }
        
        const yearValidation = this.validateYearInputs(formData.startYear, formData.endYear);
        if (!yearValidation.isValid) {
            errors.push(yearValidation.error);
        }
        
        return {
            isValid: errors.length === 0,
            errors
        };
    }
}


--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\static\js\services\visualization.js ---

export class VisualizationService {
    static createPlotConfig(data) {
        const traces = [];
        const colors = ['#2E86C1', '#E74C3C', '#2ECC71', '#F1C40F', '#9B59B6'];

        data.forEach((stockData, index) => {
            const timeData = stockData.monthly_data || stockData.yearly_data;
            if (!timeData?.length) return;

            traces.push({
                x: timeData.map(point => point.date || point.year),
                y: timeData.map(point => point.total),
                mode: 'lines+markers',
                name: `${stockData.symbol} Total`,
                line: { color: colors[index % colors.length], width: 2 },
                marker: { size: 6 },
                hovertemplate: '%{x}<br>Value: $%{y:,.2f}<extra></extra>'
            });

            if (index === 0) {
                traces.push({
                    x: timeData.map(point => point.date || point.year),
                    y: timeData.map(point => point.invested),
                    mode: 'lines',
                    name: 'Invested Amount',
                    line: { color: '#95A5A6', dash: 'dash', width: 2 },
                    hovertemplate: '%{x}<br>Invested: $%{y:,.2f}<extra></extra>'
                });
            }
        });

        return {
            traces,
            layout: {
                title: { text: 'Investment Growth Comparison', font: { size: 24 } },
                xaxis: {
                    title: 'Date',
                    tickangle: -45,
                    tickformat: '%Y-%m',
                    gridcolor: '#E0E0E0'
                },
                yaxis: {
                    title: 'Value ($)',
                    tickformat: '$,.0f',
                    rangemode: 'tozero',
                    gridcolor: '#E0E0E0'
                },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: 1.02,
                    xanchor: 'right',
                    x: 1
                },
                margin: { t: 100, b: 80, l: 80, r: 40 },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                font: { family: 'Arial, sans-serif' }
            }
        };
    }
}


--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\templates\index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investment Comparison Calculator</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="container">
        <h1>Investment Comparison Calculator</h1>
        
        <form id="calculatorForm">
            <!-- Investment inputs -->
            <div class="form-group">
                <input 
                    type="number" 
                    id="initialInvestment" 
                    placeholder="Initial Investment ($)" 
                    required 
                    min="0"
                    step="0.01">

                <input 
                    type="number" 
                    id="startYear" 
                    placeholder="Start Year" 
                    required 
                    min="1970">

                <input 
                    type="number" 
                    id="endYear" 
                    placeholder="End Year" 
                    required>
            </div>
            
            <div class="form-group">
                <input 
                    type="number" 
                    id="additionAmount" 
                    placeholder="Additional Investment ($)"
                    min="0"
                    step="0.01">

                <select id="additionFrequency">
                    <option value="none">No Additional Investment</option>
                    <option value="monthly">Monthly Addition</option>
                    <option value="annually">Annual Addition</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="adjustForInflation">
                    Adjust for Inflation
                </label>
            </div>

            <!-- Stock search -->
            <div class="stock-search-container">
                <input 
                    type="text" 
                    class="stock-search" 
                    placeholder="Search for a stock symbol (e.g., AAPL, GOOGL)..."
                    autocomplete="off">
                <div class="stock-dropdown hidden"></div>
            </div>

            <!-- Selected stocks -->
            <div class="selected-stocks"></div>

            <!-- Error container -->
            <div id="errorContainer" class="hidden">
                <div id="errorText"></div>
            </div>

            <!-- Action buttons -->
            <div class="button-group">
                <button type="submit" class="calculate">Calculate</button>
            </div>
        </form>

        <!-- Loading indicator -->
        <div id="loading" class="loading-container hidden">
            <div class="spinner"></div>
            <div class="loading-text">Calculating...</div>
        </div>

        <!-- Graph and Results -->
        <div class="graph-results-container">
            <div id="graph"></div>
            <div id="results">
                <!-- Results will be dynamically added here -->
            </div>
        </div>
    </div>
    <script type="module" src="/static/js/main.js"></script>
    <!-- <script src="/static/js/calculator.js"></script> -->
</body>
</html>

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\tests\conftest.py ---

# tests/conftest.py
import os
import sys
from pathlib import Path

# Get the project root directory
project_root = str(Path(__file__).parent.parent)

# Add the project root to Python path
sys.path.insert(0, project_root)

--- File: C:\Users\Yaniv\Desktop\Recent Projects\Investment Calculator\tests\test_validation.py ---

# tests/test_validation.py

import pytest
import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime
from services.calculation_service import CalculationService
import logging

logger = logging.getLogger(__name__)

class TestInvestmentCalculator:
    @pytest.fixture
    def calculation_service(self):
        """Fixture to create calculation service instance"""
        return CalculationService()

    @pytest.fixture
    def steady_growth_data(self):
        """Create test data with steady 10% annual growth"""
        dates = pd.date_range(start='2020-01-01', end='2022-12-31')
        daily_growth = (1.10) ** (1/252)  # 10% annual growth
        return pd.Series(
            index=dates,
            data=[100 * (daily_growth ** i) for i in range(len(dates))]
        )

    @pytest.fixture
    def volatile_growth_data(self):
        """Create test data with realistic market volatility"""
        dates = pd.date_range(start='2020-01-01', end='2022-12-31')
        np.random.seed(42)  # For reproducibility
        daily_returns = np.random.normal(0.0004, 0.02, len(dates))  # ~10% annual return with volatility
        price_series = 100 * (1 + daily_returns).cumprod()
        return pd.Series(index=dates, data=price_series)

    def test_basic_investment_growth(self, calculation_service, steady_growth_data):
        """Test basic investment growth without additions"""
        initial_investment = 10000
        stocks = {'TEST': steady_growth_data}
        
        result = calculation_service.calculate_investment_growth(
            initial=initial_investment,
            start_year=2020,
            end_year=2020,
            stocks=stocks,
            addition_amount=0,
            addition_frequency='none',
            adjust_for_inflation=False
        )
        
        # Verify structure
        assert len(result) > 0
        assert 'total' in result[-1]
        assert 'TEST' in result[-1]['total']
        
        # Verify growth
        final_value = result[-1]['total']['TEST']
        assert final_value > initial_investment
        annual_return = (final_value / initial_investment - 1) * 100
        assert abs(annual_return - 10) < 1.0  # Should be close to 10% annual return

    def test_monthly_investment(self, calculation_service, steady_growth_data):
        """Test monthly investment additions"""
        initial = 1000
        monthly_addition = 100
        stocks = {'TEST': steady_growth_data}
        
        result = calculation_service.calculate_investment_growth(
            initial=initial,
            start_year=2020,
            end_year=2020,
            stocks=stocks,
            addition_amount=monthly_addition,
            addition_frequency='monthly',
            adjust_for_inflation=False
        )
        
        # Verify total invested amount
        expected_investment = initial + (monthly_addition * 12)
        actual_investment = result[-1]['invested']
        assert abs(actual_investment - expected_investment) < 0.01, \
            f"Expected investment {expected_investment}, got {actual_investment}"
        
        # Verify returns are positive
        final_value = result[-1]['total']['TEST']
        assert final_value > actual_investment, "Investment should show positive returns"

    def test_dca_vs_lump_sum(self, calculation_service, steady_growth_data):
        """Test Dollar Cost Averaging vs Lump Sum investing"""
        total_investment = 12000
        stocks = {'TEST': steady_growth_data}
        
        # Lump sum investment
        lump_sum = calculation_service.calculate_investment_growth(
            initial=total_investment,
            start_year=2020,
            end_year=2020,
            stocks=stocks,
            addition_amount=0,
            addition_frequency='none',
            adjust_for_inflation=False
        )
        
        # DCA investment
        monthly_amount = total_investment / 12
        dca = calculation_service.calculate_investment_growth(
            initial=monthly_amount,
            start_year=2020,
            end_year=2020,
            stocks=stocks,
            addition_amount=monthly_amount,
            addition_frequency='monthly',
            adjust_for_inflation=False
        )
        
        # Verify total invested amounts
        assert abs(dca[-1]['invested'] - total_investment) < 0.01
        assert abs(lump_sum[-1]['invested'] - total_investment) < 0.01
        
        # In a steadily rising market, lump sum should outperform DCA
        lump_sum_return = lump_sum[-1]['total']['TEST'] - lump_sum[-1]['invested']
        dca_return = dca[-1]['total']['TEST'] - dca[-1]['invested']
        assert lump_sum_return > dca_return

    def test_inflation_impact(self, calculation_service, steady_growth_data):
        """Test inflation adjustment impact"""
        initial = 10000
        stocks = {'TEST': steady_growth_data}
        
        # Calculate without inflation
        nominal_result = calculation_service.calculate_investment_growth(
            initial=initial,
            start_year=2020,
            end_year=2021,
            stocks=stocks,
            addition_amount=0,
            addition_frequency='none',
            adjust_for_inflation=False
        )
        
        # Calculate with inflation
        real_result = calculation_service.calculate_investment_growth(
            initial=initial,
            start_year=2020,
            end_year=2021,
            stocks=stocks,
            addition_amount=0,
            addition_frequency='none',
            adjust_for_inflation=True
        )
        
        # Real returns should be lower than nominal returns
        nominal_value = nominal_result[-1]['total']['TEST']
        real_value = real_result[-1]['total']['TEST']
        assert real_value < nominal_value
        
        # With 2% inflation, real value should be about 2% lower than nominal
        expected_ratio = 1 / 1.02  # One year of 2% inflation
        actual_ratio = real_value / nominal_value
        assert abs(actual_ratio - expected_ratio) < 0.01

    def test_multiple_stocks(self, calculation_service):
        """Test calculations with multiple stocks"""
        # Create test data for two stocks
        dates = pd.date_range(start='2020-01-01', end='2020-12-31')
        stock1_data = pd.Series(
            index=dates,
            data=[100 * (1.15 ** (i/252)) for i in range(len(dates))]  # 15% annual growth
        )
        stock2_data = pd.Series(
            index=dates,
            data=[100 * (1.08 ** (i/252)) for i in range(len(dates))]  # 8% annual growth
        )
        
        stocks = {
            'STOCK1': stock1_data,
            'STOCK2': stock2_data
        }
        
        result = calculation_service.calculate_investment_growth(
            initial=10000,
            start_year=2020,
            end_year=2020,
            stocks=stocks,
            addition_amount=0,
            addition_frequency='none',
            adjust_for_inflation=False
        )
        
        # Verify both stocks are calculated
        final_data = result[-1]
        assert 'STOCK1' in final_data['total']
        assert 'STOCK2' in final_data['total']
        
        # STOCK1 should outperform STOCK2
        assert final_data['total']['STOCK1'] > final_data['total']['STOCK2']

    def test_real_stock_data(self, calculation_service):
        """Test with real historical stock data"""
        try:
            # Fetch real data for a well-known stock
            spy_data = yf.download('SPY', 
                                 start='2020-01-01', 
                                 end='2020-12-31')['Close']
            
            result = calculation_service.calculate_investment_growth(
                initial=10000,
                start_year=2020,
                end_year=2020,
                stocks={'SPY': spy_data},
                addition_amount=0,
                addition_frequency='none',
                adjust_for_inflation=False
            )
            
            # Verify basic expectations
            assert len(result) > 0
            assert 'SPY' in result[-1]['total']
            
        except Exception as e:
            pytest.skip(f"Failed to fetch real stock data: {str(e)}")

    def test_edge_cases(self, calculation_service, steady_growth_data):
        """Test edge cases and error handling"""
        stocks = {'TEST': steady_growth_data}
        
        # Test zero initial investment
        result = calculation_service.calculate_investment_growth(
            initial=0,
            start_year=2020,
            end_year=2020,
            stocks=stocks,
            addition_amount=100,
            addition_frequency='monthly',
            adjust_for_inflation=False
        )
        assert result[-1]['invested'] > 0, "Should handle zero initial investment"
        
        # Test single day investment period
        short_data = steady_growth_data['2020-01-01':'2020-01-01']
        result = calculation_service.calculate_investment_growth(
            initial=1000,
            start_year=2020,
            end_year=2020,
            stocks={'TEST': short_data},
            addition_amount=0,
            addition_frequency='none',
            adjust_for_inflation=False
        )
        assert len(result) > 0, "Should handle single day period"

    @pytest.mark.parametrize("addition_frequency", ['monthly', 'annually', 'none'])
    def test_different_frequencies(self, calculation_service, steady_growth_data, addition_frequency):
        """Test different investment frequencies"""
        initial = 1000
        addition_amount = 100
        
        result = calculation_service.calculate_investment_growth(
            initial=initial,
            start_year=2020,
            end_year=2020,
            stocks={'TEST': steady_growth_data},
            addition_amount=addition_amount,
            addition_frequency=addition_frequency,
            adjust_for_inflation=False
        )
        
        # Verify invested amount based on frequency
        expected_additions = {
            'monthly': 12 * addition_amount,
            'annually': addition_amount,
            'none': 0
        }
        
        expected_total = initial + expected_additions[addition_frequency]
        assert abs(result[-1]['invested'] - expected_total) < 0.01, \
            f"Incorrect total for {addition_frequency} frequency"

if __name__ == '__main__':
    pytest.main(['-v'])